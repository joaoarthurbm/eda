<!doctype html>

<html lang="en">

<head>
  <title>Estruturas de Dados e Algoritmos</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="João Arthur Brunet" /><meta name="generator" content="Hugo 0.68.3" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />
  <script src="https://kit.fontawesome.com/b76b73e8e8.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://joaoarthurbm.github.io/eda/css/styles.css" /><script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151903059-1"></script>
<script>
      window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

            gtag('config', 'UA-151903059-1');
        </script>


</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://joaoarthurbm.github.io/eda/">Estruturas de Dados e Algoritmos</a>
            </h1>

      <ul id="social-media">
        
        
        
        <li><a href="https://twitter.com/joaobrunet"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="http://joaoarthurbm.github.io"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
           
        <li><a href="https://instagram.com/joaoarthurbm"><i class="fab fa-instagram fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>João Arthur Brunet <br> Computação @ UFCG</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/curso/">
                <i class="fa-li fa  fa-lg"></i><span>Curso</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/objetivos/">
                <i class="fa-li fa  fa-lg"></i><span>Objetivos</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/conteudo/">
                <i class="fa-li fa  fa-lg"></i><span>Conteúdo</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/contribua/">
                <i class="fa-li fa  fa-lg"></i><span>Contribua</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/bibliografia/">
                <i class="fa-li fa  fa-lg"></i><span>Bibliografia</span>
            </a>
        </li>
        
    </ul>
</nav>
    <main>




<article>

    <h1>Ordenação por Comparação: Insertion Sort</h1>    

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-10-27T01:01:01-03:00">Oct 27, 2019</time>
        </li>
        

        

        <li>7 minutos de leitura</li>


        


        

        <aside><i class="fab fa-youtube fa-lg" aria-hidden="true"> </i> <a href="https://youtu.be/cv_NSHQrUZc"> <font color="#1980e6"> <b>vídeo aula</b></font></a></aside>
        



        

        <aside><i class="fab fa-github fa-lg" aria-hidden="true"> </i> <a href="https://github.com/joaoarthurbm/eda-implementacoes/blob/master/java/src/sorting/Insertion.java"> <font color="#1980e6"> <b>Código utilizado neste material</b></font></a></aside>
        


    </ul>
</aside>

    

    <hr>
<h1 id="direto-ao-ponto">Direto ao ponto</h1>
<p>O <em>Insertion Sort</em> tem como rotina base a inserção ordenada. A ideia é executar várias vezes essa rotina para ordenar um array. Para ser exato, se executarmos $N - 1$ vezes a rotina de inserção ordenada em um array o resultado é a ordenação completa do mesmo. Por isso, vamos antes entender como funciona inserção ordenada.</p>
<h1 id="inserção-ordenada">Inserção ordenada</h1>
<p>Vamos analisar o caso de um array com $N$ elementos no qual os $N - 1$ primeiros elementos estão ordenados, mas o último elemento não está no seu lugar. Isto é, precisamos encaixar o último elemento de forma que a sequência fique ordenada. No exemplo abaixo, estamos falando em inserir de forma ordenada o valor 12.</p>
<p align="center">values =[9, 13, 16, 21, 32, <font color="red">12</font>]</p>
<p>Como a sequência está ordenada até o penúltimo índice, a ideia é comparar 12 com o valor anterior e, se 12 for menor, trocar esses valores. Essas comparações e trocas só devem parar quando 12 for maior que o elemento à esquerda ou quando 12 estiver na primeira posição do array. Para visualizar o Insertion Sort, alguns autores utilizam a metáfora de uma mão de cartas. Nesse contexto, o objetivo seria encaixar a carta 12 na mão já ordenada. Veja o passo a passo:</p>
<p align="center">values = [9, 13, 16, 21, <font color="red">12</font>, 32]</p>
<p align="center">values = [9, 13, 16, <font color="red">12</font>, 21, 32]</p>
<p align="center">values = [9, 13, <font color="red">12</font>, 16, 21, 32]</p>
<p align="center">values = [9, <font color="red">12</font>, 13, 16, 21, 32]</p>
<p>O código que implementa essa rotina está descrito abaixo. O índice <code>j</code> assume o valor inicial <code>values.length - 1</code> (última posição) e a condição de parada do laço é satisfeita quando esse índice alcançar 0 ou quando o valor que queremos inserir de forma ordenada já está na sua posição (<code>values[j] &gt;= values[j-1]</code>). Se <code>j</code> alcançar 0, todo o array foi avaliado e o algoritmo deve parar. Da mesma forma, se <code>values[j] &gt;= values[j-1]</code> o algoritmo deve parar porque o elemento que estamos querendo encaixar já está em seu lugar.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
	<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> values<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>

	<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> values<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> values<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> aux <span style="color:#f92672">=</span> values<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
            values<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> values<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">];</span>
            values<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">;</span>
            j <span style="color:#f92672">-=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><h1 id="insertion-sort">Insertion Sort</h1>
<p>A parte complexa desse algoritmo de ordenação nós já entendemos &ndash; a inserção ordenada.</p>
<blockquote>
<p>O Insertion Sort aplica várias vezes a inserção ordenada para ordenar uma sequência.</p>
</blockquote>
<p>Vamos ver como isso é feito.</p>
<p>Queremos ordenar $values = [7, 1, 2, 3, 9, 5, 1]$. Se pensarmos bem, podemos ver os dois primeiros elementos desse array como sendo o cenário apresentado na seção anterior, isto é, temos que $[7, 1]$ está ordenado, exceto pela última posição. Se aplicarmos inserção ordenada em $[7, 1]$, temos como resultado $[1, 7]$.</p>
<p>Agora, vamos adotar a mesma postura com os três primeiros elementos: $[1, 7, 2]$. Novamente, podemos ver os 3 primeiros elementos como sendo o cenário para a inserção ordenada. Isto é $[1, 7, 2]$ está ordenado, exceto pelo último elemento. Se aplicarmos inserção ordenada em $[1, 7, 2]$, temos como resultado $[1, 2, 7]$.</p>
<p>Depois, vamos adotar a mesma postura com os quatro primeiros elementos: $[1, 2, 7, 3]$. Isto é, está ordenado, exceto pelo último elemento. Então basta aplicarmos inserção ordenada de 3. O resultado é $[1, 2, 3, 7]$.</p>
<p>Esse processo segue até o array ficar ordenado. Você percebeu que aplicamos inserção ordenada partindo do segundo elemento do array até o final? Isso significa que basta colocarmos um <em><strong>loop</strong></em> externo ao código de inserção ordenada, fazendo <code>j</code> variar de 1 até o último elemento. Vamos ao código:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertionSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> values<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
	<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> values<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span> 
		
		<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
	
		<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> values<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> values<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
			<span style="color:#66d9ef">int</span> aux <span style="color:#f92672">=</span> values<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
			values<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> values<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
			values<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">;</span>
			j <span style="color:#f92672">-=</span> 1<span style="color:#f92672">;</span>
		<span style="color:#f92672">}</span>
	
	<span style="color:#f92672">}</span>	
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>A única mudança que fizemos foi adicionar o comando <em><strong>for</strong></em> com <code>i</code> variando de 1 até o final e <code>j</code> variando de acordo com <code>i</code>.</p>
<p>Para fixar bem, veja a animação abaixo copiada <a class="external" href="https://medium.com/yay-its-erica/algorithms-for-beginners-bubble-sort-insertion-sort-merge-sort-29bd5506cc48"> deste material.</a> Note que a ideia é sempre inserir um elemento em uma sequência já ordenada.</p>
<figure style="align: center; margin-left:20%; width: 60%">
	<img src="animacao.gif">
</figure>
<p>Eu também gravei um vídeo explicando o Insertion Sort.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/cv_NSHQrUZc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h2 id="propriedades-e-análise-de-eficiência">Propriedades e Análise de eficiência</h2>
<blockquote>
<p>O Insertion Sort é estável, in-place e $O(n^2)$.</p>
</blockquote>
<p>Estabilidade é uma propriedade relacionada à ordem relativa de valores iguais no array original. Por exemplo, se houver dois valores 97 no array antes da ordenação, após a execução do algoritmo, esses dois valores devem seguir a ordem relativa inicial. Ou seja, ao término da execução do algoritmo, a primeira ocorrência do 97 deve vir antes da segunda ocorrência do 97.</p>
<p>O Insertion Sort é estável porque mantém a ordem relativa dos valores iguais. Isso ocorre porque as trocas são feitas sempre com vizinhos. Os valores vão sendo &ldquo;afastados&rdquo; um a um, e não dando saltos. Por isso, um elemento qualquer nunca trocará de posição com elementos de mesmo valor.</p>
<p>O Insertion Sort é <em>in-place</em> porque a ordenação é feita rearranjando os elementos no próprio array, ao invés de usar arrays ou outras estruturas auxiliares.</p>
<p>O pior caso do Insertion Sort é um array ordenado em ordem reversa, pois toda tentativa de inserção ordenada deve percorrer o array todo à esquerda trocando os elementos até encaixar o atual na primeira posição. Veja o exemplo:</p>
<p>Inserção ordenada de 20:</p>
<p align="center">values = [90, <font color="red">20</font>, 16, 5, 1]</p>
<p align="center">values = [<font color="red">20</font>, 90, 16, 5, 1]</p>
<p>Inserção ordenada de 16:</p>
<p align="center">values = [20, 90, <font color="red">16</font>, 5, 1]</p>
<p align="center">values = [20, <font color="red">16</font>, 90, 5, 1]</p>
<p align="center">values = [<font color="red">16</font>, 20, 90, 5, 1]</p>
<p>Inserção ordenada de 5:</p>
<p align="center">values = [16, 20, 90, <font color="red">5</font>, 1]</p>
<p align="center">values = [16, 20, <font color="red">5</font>, 90, 1]</p>
<p align="center">values = [16, <font color="red">5</font>, 20, 90, 1]</p>
<p align="center">values = [<font color="red">5</font>, 15, 20, 90, 1]</p>
<p>Inserção ordenada de 1:</p>
<p align="center">values = [5, 15, 20, 90, <font color="red">1</font>]</p>
<p align="center">values = [5, 15, 20, <font color="red">1</font>, 90]</p>
<p align="center">values = [5, 15, <font color="red">1</font>, 20, 90]</p>
<p align="center">values = [5, <font color="red">1</font>, 15, 20, 90]</p>
<p align="center">values = [<font color="red">1</font>, 5, 15, 20, 90]</p>
<p>Feito. Array ordenado.</p>
<p>Note que o tempo de execução é dado pela soma dos passos de cada iteração. Essa soma pode ser representada por $1 + 2 + 3 + &hellip; (n - 1)$, ou seja, uma Progressão Aritmética Finita (PA) com $a_1 = 1$ e $a_n = (n - 1)$ e razão $r=1$. A soma dos termos de uma PA é dada por: $(a_1+a_n)*n/2$. Então, temos que o tempo de execução do algoritmo é dado por $(1 + (n - 1)) * n/2 = (n^2)/2$. Aplicando as diretrizes de simplificação, o Insertion Sort é $\Theta(n^2)$.</p>
<p>No melhor caso, este algoritmo é $O(n)$. Isto ocorre quando o array já está ordenado. Deste maneira, a inserção ordenada de cada elemento tem custo $O(1)$, pois todos já estão em suas devidas posições. Como a inserção ordenada é executada $n$ vezes, o custo total é $O(n)$</p>
<p>É importante destacar que o Insertion Sort não é considerado um algoritmo eficiente para grandes entradas. Há alternativas $O(n*\log n)$, como Quick Sort e Merge Sort, além de alternativas lineares como o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/">Counting Sort</a>.</p>
<p>É também importante traçar o paralelo entre o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/selection-sort/">Selection Sort</a> e o Insertion Sort. O Selection efetua menos trocas do que o Insertion, pois há uma troca apenas por iteração, ou seja, no total o Selection Sort efetua $n$ trocas. Já o insertion sort efetua ao menos uma troca por iteração, pois deve efetuar trocas para afastar cada elemento avaliado.</p>
<p>Por outro lado, o Insertion Sort efetua menos comparações do que o Selection Sort, pois nem sempre o elemento a ser inserido de forma ordenada deve ir até o final. Na verdade, isso só acontece no pior dos casos, em que o array está ordenado em ordem reversa. Já o Selection Sort precisa comparar todos os elementos restante cada vez para determinar quem é o menor deles.</p>
<p>Na teoria, ambos estão na mesma classe de complexidade, qual seja $O(n^2)$. Na prática, o Insertion Sort apresenta melhor desempenho do que o Selection Sort.</p>
<hr>
<h1 id="resumo">Resumo</h1>
<ul>
<li>
<p>O Insertion Sort nada mais é do que a execução do algoritmo de inserção ordenada repetidas vezes.</p>
</li>
<li>
<p>O Insertion Sort é in-place, estável e $O(n^2)$.</p>
</li>
<li>
<p>O pior caso da execução deste algoritmo manifesta-se quando a entrada está ordenada em ordem decrescente.</p>
<ul>
<li>No melhor caso o Insertion Sort é $O(n)$. Isso ocorre quando o array já está ordenado.</li>
</ul>
</li>
<li>
<p>Na teoria, Insertion Sort, <a class="external" href="https://joaoarthurbm.github.io/eda/posts/selection-sort/">Selection Sort</a>  e Bubble Sort estão na mesma classe de complexidade, qual seja $O(n^2)$. Na prática, o Insertion Sort apresenta o melhor desempenho entre esses 3 algoritmos.</p>
</li>
</ul>
<hr>
<h1 id="notas">Notas</h1>
<p>Vale a pena utilizar o <a class="external" href="https://visualgo.net/en/sorting">VisuAlgo</a> para visualizar a execução do Selection Sort e de outros algoritmos de ordenação.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/merge-sort/"><i class="fa fa-chevron-circle-left"></i> Ordenação por Comparação: Merge Sort</a>
        </li>
        
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/selection-sort/">Ordenação por Comparação: Selection Sort <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
    <h6><a href="http://joaoarthurbm.github.io">Copyright © 2019 - João Arthur Brunet</a></h6>
    </footer>
</div>
<script src="https://joaoarthurbm.github.io/eda/js/scripts.js"></script>

</body>

</html>

