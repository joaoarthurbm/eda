<!doctype html>

<html lang="en">

<head>
  <title>Estruturas de Dados e Algoritmos</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="João Arthur Brunet" /><meta name="generator" content="Hugo 0.68.3" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />
  <script src="https://kit.fontawesome.com/b76b73e8e8.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://joaoarthurbm.github.io/eda/css/styles.css" /><script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151903059-1"></script>
<script>
      window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

            gtag('config', 'UA-151903059-1');
        </script>


</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://joaoarthurbm.github.io/eda/">Estruturas de Dados e Algoritmos</a>
            </h1>

      <ul id="social-media">
        
        
        
        <li><a href="https://twitter.com/joaobrunet"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="http://joaoarthurbm.github.io"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
           
        <li><a href="https://instagram.com/joaoarthurbm"><i class="fab fa-instagram fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>João Arthur Brunet <br> Computação @ UFCG</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/curso/">
                <i class="fa-li fa  fa-lg"></i><span>Curso</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/objetivos/">
                <i class="fa-li fa  fa-lg"></i><span>Objetivos</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/conteudo/">
                <i class="fa-li fa  fa-lg"></i><span>Conteúdo</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/contribua/">
                <i class="fa-li fa  fa-lg"></i><span>Contribua</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/bibliografia/">
                <i class="fa-li fa  fa-lg"></i><span>Bibliografia</span>
            </a>
        </li>
        
    </ul>
</nav>
    <main>




<article>

    <h1>Ordenação por Comparação: Selection Sort</h1>    

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-10-27T02:01:01-03:00">Oct 27, 2019</time>
        </li>
        

        

        <li>6 minutos de leitura</li>


        


        

        <aside><i class="fab fa-youtube fa-lg" aria-hidden="true"> </i> <a href="https://youtu.be/eErcqHuaUmQ"> <font color="#1980e6"> <b>vídeo aula</b></font></a></aside>
        



        

        <aside><i class="fab fa-github fa-lg" aria-hidden="true"> </i> <a href="https://github.com/joaoarthurbm/eda-implementacoes/blob/master/java/src/sorting/Selection.java"> <font color="#1980e6"> <b>Código utilizado neste material</b></font></a></aside>
        


    </ul>
</aside>

    

    <hr>
<h1 id="direto-ao-ponto">Direto ao ponto</h1>
<p>Se você pedir para alguém que não é familiarizado com algoritmos para que ordene uma sequência de números, há uma probabilidade alta dessa pessoa aplicar o Selection Sort. Isso porque esse algoritmo tem uma rotina básica muito simples e direta: selecionar (daí o nome Selection Sort) o menor elemento da sequência e colocar esse elemento na primeira posição do array. A ideia é executar várias vezes esses dois passos para ordenar um array. Para ser exato, se executarmos $N$ vezes esses dois passos em um array, controlando os índices em que os passos são executados, o resultado é a ordenação completa do mesmo.</p>
<h1 id="selection-sort">Selection Sort</h1>
<h2 id="selecionando-o-menor">Selecionando o menor</h2>
<p>Este algoritmo é elementar. Basta percorrer o array comparando os elementos para determinar qual é o menor. No início, assumimos que o menor elemento está no índice 0 (<code>indice_menor = 0</code>) e iteramos a partir do segundo índice comparando os elementos.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
	<span style="color:#75715e">// encontra o índice do menor elemento
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> indice_menor <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
	<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> v<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
		<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> v<span style="color:#f92672">[</span>indice_menor<span style="color:#f92672">])</span>
			indice_menor <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>

	<span style="color:#75715e">// coloca o menor na primeira posição
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> aux <span style="color:#f92672">=</span> v<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
	v<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">[</span>indice_menor<span style="color:#f92672">];</span>
	v<span style="color:#f92672">[</span>indice_menor<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>Ao fim da execução deste algoritmo temos uma certeza: o menor elemento está no índice 0 do array.</p>
<h2 id="como-usar-esta-rotina-para-ordenar-um-array">Como usar esta rotina para ordenar um array?</h2>
<p>Ora, basta repetir esse mesmo processo para o restante do array. Vamos ver a execução para o $values = [70, 90, 1, 3, 0, 100, 2]$</p>
<p>Na primeira execução, 0 é o menor valor. Encontramos esse valor e trocamos com a primeira posição (70).</p>
<p align="center">[<font color="blue">70</font>, 90, 1, 3, <font color="red">0</font>, 100, 2]</p>
<p align="center">[<font color="red">0</font>, 90, 1, 3, <font color="blue">70</font>, 100, 2]</p>
<p>Agora, aplicamos a mesma ideia para o restante do array, ou seja, no intervalo de índices $[1, values.length - 1]$.</p>
<p align="center">[0, <font color="blue">90</font>, <font color="red">1</font>, 3, 70, 100, 2]</p>
<p align="center">[0, <font color="red">1</font>, <font color="blue">90</font>, 3, 70, 100, 2]</p>
<p>Depois, aplicamos a mesma ideia para o restante do array, ou seja, no intervalo de índices $[2, values.length - 1]$.</p>
<p align="center">[0, 1, <font color="blue">90</font>, 3, 70, 100, <font color="red">2</font>]</p>
<p align="center">[0, 1, <font color="red">2</font>, 3, 70, 100, <font color="blue">90</font>]</p>
<p>Continuamos aplicando a mesma ideia para o restante do array, ou seja, no intervalo de índices $[3, values.length - 1]$. Como 3 já está no seu lugar, ele será trocado por ele mesmo. O mesmo acontece com o intervalo de índices $[4, values.length - 1]$, onde 70 já está em sua posição.</p>
<p>Aplicando, então, para o intervalo de índices $[5, values.length - 1]$, temos:</p>
<p align="center">[0, 1, 2, 3, 70, <font color="blue">100</font>, <font color="red">90</font>]</p>
<p align="center">[0, 1, 2, 3, 70, <font color="red">90</font>, <font color="blue">100</font>]</p>
<p>Por fim, aplicado para o intervalo $[6, values.length - 1]$, temos que 100 já está em sua posição.</p>
<p>Feito! O array está ordenado. Note que apenas executamos a rotina de encontrar o menor e colocar na primeira posição várias vezes. Para ser exato, executamos $N$ vezes, variando a faixa de valores que o algoritmo deve avaliar.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectionSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>	
	<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> v<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
		
		<span style="color:#66d9ef">int</span> i_menor <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> v<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span>
			<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> v<span style="color:#f92672">[</span>i_menor<span style="color:#f92672">])</span>
				i_menor <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
		
		<span style="color:#66d9ef">int</span> aux <span style="color:#f92672">=</span> v<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
		v<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">[</span>i_menor<span style="color:#f92672">];</span>
		v<span style="color:#f92672">[</span>i_menor<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">;</span>
	
	<span style="color:#f92672">}</span>		
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>Abaixo podemos ver uma animação produzida pelo <a class="external" href="https://algorithms.tutorialhorizon.com/selection-sort-java-implementation/selection-sort-gif/">TutorialHorizon</a>.</p>
<figure style="align: center; margin-left:20%; width: 60%">
	<img src="selection.gif">
</figure>
<p>Eu também gravei um vídeo explicando o Selection Sort.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/eErcqHuaUmQ" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h2 id="propriedades-e-análise-de-eficiência">Propriedades e Análise de eficiência</h2>
<blockquote>
<p>O Selection Sort é in-place e $O(n^2)$, mas não é estável.</p>
</blockquote>
<p>Lembrando que estabilidade é uma propriedade relacionada à ordem relativa de valores iguais no array original. Por exemplo, se houver dois valores 97 no array antes da ordenação, após a execução do algoritmo, esses dois valores devem seguir a ordem relativa inicial. Ou seja, ao término da execução do algoritmo, a primeira ocorrência do 97 deve vir antes da segunda ocorrência do 97.</p>
<p>O Selection Sort não é estável porque dependendo das trocas, ele não mantém a ordem relativa dos valores iguais. Vamos analisar um exemplo em que isso acontece. Para diferenciar valores iguais, vou colocar os subscritos $a$ e $b$, ok?</p>
<p align="center">$values = [1, 7_a, 7_b, 2] $</p>
<p>Na primeira iteração, o menor valor é 1 e, por isso, fica na posição em que está. Depois, na segunda iteração o menor valor é 2 e deve trocar de lugar com $7_a$. O resultado parcial é:</p>
<p align="center">$values = [1, 2, 7_b, 7_a] $</p>
<p>Na terceira iteração $7_b$ é o menor e fica no lugar em que está. Na última iteração $7_a$ já o menor do array restante e fica no lugar em que está.</p>
<p>Como resultado, temos que $7_a$ vinha antes de $7_b$ no array original, mas essa ordem relativa foi trocada depois da ordenação. Portanto, o algoritmo não é estável.</p>
<p>O Selection Sort é <em>in-place</em> porque a ordenação é feita rearranjando os elementos no próprio array, ao invés de usar arrays ou outras estruturas auxiliares.</p>
<p>O Selection Sort é $O(n^2)$. A busca pelo menor elemento custa $n - 1$ passos na primeira iteração, $n - 2$ passos na segunda, $n - 3$ passos na terceira e assim por diante. Assim como no caso do <a class="external" href="https://joaoarthurbm.github.io/eda/posts/insertion-sort/">Insertion Sort</a>, o custo é dado pela soma dos termos da Progressão Aritmética $1 + 2 + 3 + &hellip; (n - 1)$, com $a_1 = 1$ e $a_n = (n - 1)$ e razão $r=1$. A soma dos termos de uma PA é dada por: $(a_1+a_n)*n/2$. Então, temos que o tempo de execução do algoritmo é dado por $(1 + (n - 1)) * n/2 = (n^2)/2$. Aplicando as diretrizes de simplificação, o Selection Sort é $\Theta(n^2)$.</p>
<p>É importante traçar o paralelo entre o Selection Sort e o Insertion Sort. O Selection efetua menos trocas do que o Insertion, pois há uma troca apenas por iteração, ou seja, no total o Selection Sort efetua $n$ trocas. Já o insertion sort efetua ao menos uma troca por iteração, pois deve efetuar trocas para afastar cada elemento avaliado.</p>
<p>Por outro lado, o Insertion Sort efetua menos comparações do que o Selection Sort, pois nem sempre o elemento a ser inserido de forma ordenada deve ir até o final. Na verdade, isso só acontece no pior dos casos, em que o array está ordenado em ordem reversa. Já o Selection Sort precisa comparar todos os elementos restante cada vez para determinar quem é o menor deles.</p>
<p>Na teoria, ambos estão na mesma classe de complexidade, qual seja $O(n^2)$. Na prática, o Insertion Sort apresenta melhor desempenho do que o Selection Sort.</p>
<p>Por fim, O Selection Sort não é considerado um algoritmo eficiente para grandes entradas. Há alternativas $O(n*\log n)$, como Quick Sort e Merge Sort, além de alternativas lineares como o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/">Counting Sort</a>.</p>
<hr>
<h1 id="resumo">Resumo</h1>
<ul>
<li>
<p>O Selection Sort segue uma rotina bem simples e direta: encontrar o menor elemento e colocá-lo na primeira posição. A ordenação nada mais é do que aplicar essa rotina repetidas vezes para o restante do array.</p>
</li>
<li>
<p>O Selection sort é in-place e $O(n^2)$.</p>
</li>
<li>
<p>A implementação clássica do Selection Sort não é estável.</p>
</li>
<li>
<p>Embora sejam da mesma classe de complexidade, o Selection Sort, na prática, é mais lento do que o Insertion Sort.</p>
</li>
<li>
<p>O Selection Sort não é considerado um algoritmo eficiente para grandes entradas. Há alternativas $O(n*\log n)$, como Quick Sort e Merge Sort, além de alternativas lineares como o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/">Counting Sort</a>.</p>
</li>
</ul>
<hr>
<h1 id="notas">Notas</h1>
<p>Vale a pena utilizar o <a class="external" href="https://visualgo.net/en/sorting">VisuAlgo</a> para visualizar a execução do Selection Sort e de outros algoritmos de ordenação.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/insertion-sort/"><i class="fa fa-chevron-circle-left"></i> Ordenação por Comparação: Insertion Sort</a>
        </li>
        
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/analise-algoritmos-recursivos/">Análise de Algoritmos Recursivos <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
    <h6><a href="http://joaoarthurbm.github.io">Copyright © 2019 - João Arthur Brunet</a></h6>
    </footer>
</div>
<script src="https://joaoarthurbm.github.io/eda/js/scripts.js"></script>

</body>

</html>

