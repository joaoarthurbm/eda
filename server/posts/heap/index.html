<!doctype html>

<html lang="en">

<head>
  <title>Estruturas de Dados e Algoritmos</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="João Arthur Brunet" /><meta name="generator" content="Hugo 0.68.3" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />
  <script src="https://kit.fontawesome.com/b76b73e8e8.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://joaoarthurbm.github.io/eda/css/styles.css" /><script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151903059-1"></script>
<script>
      window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

            gtag('config', 'UA-151903059-1');
        </script>


</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://joaoarthurbm.github.io/eda/">Estruturas de Dados e Algoritmos</a>
            </h1>

      <ul id="social-media">
        
        
        
        <li><a href="https://twitter.com/joaobrunet"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="http://joaoarthurbm.github.io"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
           
        <li><a href="https://instagram.com/joaoarthurbm"><i class="fab fa-instagram fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>João Arthur Brunet <br> Computação @ UFCG</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/curso/">
                <i class="fa-li fa  fa-lg"></i><span>Curso</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/objetivos/">
                <i class="fa-li fa  fa-lg"></i><span>Objetivos</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/conteudo/">
                <i class="fa-li fa  fa-lg"></i><span>Conteúdo</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/contribua/">
                <i class="fa-li fa  fa-lg"></i><span>Contribua</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/bibliografia/">
                <i class="fa-li fa  fa-lg"></i><span>Bibliografia</span>
            </a>
        </li>
        
    </ul>
</nav>
    <main>




<article>

    <h1>Heap</h1>    

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-10-22T00:00:00-03:00">Oct 22, 2019</time>
        </li>
        

        

        <li>21 minutos de leitura</li>


        


        



        

        <aside><i class="fab fa-github fa-lg" aria-hidden="true"> </i> <a href="https://github.com/joaoarthurbm/eda-implementacoes/tree/master/java/src/heap"> <font color="#1980e6"> <b>Código utilizado neste material</b></font></a></aside>
        


    </ul>
</aside>

    

    <hr>
<p>Nem toda fila segue a política de acesso <em>First In First Out</em> (FIFO). Na verdade, em vários cenários do dia a dia, as filas que entramos possuem uma política diferente: são filas de prioridade. Por exemplo, mesmo que um adolescente chegue antes de um idoso na fila do banco, é provável que o idoso seja atendido primeiro porque ele tem, por lei (e deveria ter por civilidade também), <strong>prioridade</strong> no atendimento.</p>
<p>No contexto de estrutura de dados, precisamos pensar em como manter a estrutura ordenada tendo como critério essa prioridade. Então, vamos primeiro analisar alternativas para implementar filas de prioridade usando estruturas de dados lineares, como <a class="external" href="https://joaoarthurbm.github.io/eda/posts/linkedlist/">LinkedList</a> ou <a class="external" href="https://joaoarthurbm.github.io/eda/posts/arraylist/">ArrayList</a>. 
Em primeiro lugar, os objetos passam a ter uma prioridade, que é representada por um atributo inteiro. No nosso exemplo, quanto maior esse número, maior a prioridade. Nesse caso, para implementarmos uma fila de prioridade, temos que tomar uma decisão:  manter a fila ordenada ou não?</p>
<p>Se decidirmos manter a fila sempre ordenada tendo como critério a prioridade, precisamos utilizar o algoritmo de inserção ordenada, cujo custo é $O(n)$. Contudo, a extração do maior elemento é ${O(1)}$, pois ele sempre está no início da fila.</p>
<p>Se optarmos por não manter a fila ordenada por prioridade, temos o cenário oposto. A adição passa a ser $O(1)$, mas a remoção do maior passa a ser $O(n)$, pois teremos que pesquisar em toda a fila a maior prioridade.</p>
<p>Em resumo, temos de um lado adição $O(n)$ e remoção $O(1)$ e do outro lado temos adição $O(1)$ e remoção $O(n)$.</p>
<p>A estrutura que veremos neste material, <em>Heap</em>, resolve essa questão permitindo que a adição e extração do máximo sejam ambas realizadas em $O(\log n)$, o que é muito desejável do ponto de vista de eficiência. Além disso, o máximo fica sempre na raiz dessa estrutura, o que permite sua inspeção em $O(1)$.</p>
<hr>
<h1 id="definições-e-propriedades">Definições e Propriedades</h1>
<p><em>Heaps</em> são árvores binárias. É importante deixar claro desde já que são árvores binárias, mas não são árvores binárias de pesquisa. Mais especificamente, duas propriedades definem o Heap:</p>
<pre>
1. O valor de um nó é maior ou igual ao valor de seus filhos;

2. O Heap é uma árvore binária completa ou quase-completa 
da esquerda para a direita.
</pre>
<p><strong>Propriedade 1.</strong> A primeira propriedade é a que difere um Heap de uma árvore binária de pesquisa (BST). Na BST, os valores à esquerda de um nó são menores do que ele e os valores à direita são maiores. No Heap, ambos são menores ou iguais. Heaps que seguem essa propriedade são Heaps Máximos porque o maior valor sempre está na raiz. Há também Heaps Mínimos, onde o nó tem valor sempre menor ou igual ao seus filhos. Neste caso, o menor valor sempre está na raiz. Neste material, vamos utilizar o termo Heap como sinônimo de Heap Máximo.</p>
<p><strong>Propriedade 2.</strong> Se você leu o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/bst">material de árvores binárias de pesquisa</a>, você já sabe o que quer dizer uma árvore completa, certo? Mas,</p>
<p align="center">o que quer dizer <i>quase-completa da esquerda para a direita?</i></p>
<p>Quer dizer que, se ela não for completa, todos os níveis estão preenchidos, exceto o último, que deve estar preenchido da esquerda para a direita até um certo ponto. Vamos ver exemplos de Heaps e Não-Heaps para esclarecer esse conceito.</p>
<p>Para exemplos de Heaps, vamos analisar a figura abaixo. Perceba que, além de satisfazerem a propriedade 1, todas as estruturas são completas ou quase-completas da esquerda para a direita e, portanto, são Heaps.</p>
<p><img src="heaps.png" alt="heaps"></p>
<p>A primeira estrutura possui 3 níveis:</p>
<ul>
<li>Nível 0: 92</li>
<li>Nível 1: 92 e 6</li>
<li>Nível 2: 48 e 70</li>
</ul>
<p>O nível 0 e o nível 1 estão completamente preenchidos. O único nível que não está preenchido é o último, mas ele está parcialmente preenchido da esquerda para a direita (46 e 70). Note que não há &ldquo;salto&rdquo; ao percorrer a estrutura em largura. Por isso, essa estrutura é um Heap.</p>
<p>A segunda estrutura é um Heap porque respeita a primeira propriedade e é uma árvore binária completa.</p>
<p>A terceira estrutura é um Heap porque respeita a primeira propriedade e é quase-completa da esquerda para a direita. Novamente, todos os níveis exceto o último estão completamente preenchidos e o último nível está parcialmente preenchido da esquerda para a direita:</p>
<ul>
<li>Nível 0: 93</li>
<li>Nível 1: 74 e 67</li>
<li>Nível 2: 63, 53, 16 e 41</li>
<li>Nível 3: 5, 3, 25 e 10 (parcialmente preenchido da esquerda para a direita)</li>
</ul>
<p>Note que, se removêssemos o 25 dessa estrutura, ela não seria mais um Heap, pois o último nível não estaria preenchido da esquerda para a direita. Haveria um salto entre 3 e 10.</p>
<p>Agora, para fixar bem, vamos ver exemplos de estruturas que não são completas ou quase-completas da esquerda para a direita e, portanto, não são Heaps.</p>
<p><img src="nao-heaps.png" alt="nao-heaps"></p>
<p>Em primeiro lugar, nenhuma das estruturas acima é completa. Agora precisamos checar se são quase-completas da esquerda para a direita.</p>
<p>A primeira estrutura não é quase-completa da esquerda para a direita. Veja:</p>
<ul>
<li>Nível 0: 92. Ok. Está todo preenchido.</li>
<li>Nível 1: 92. Não está todo preenchido. Por isso não é quase-completa da esquerda para a direita.</li>
<li>Nível 2: 48 e 70. Está preenchido da esquerda para a direita, mas o nível anterior não. Por isso não está ok.</li>
</ul>
<p>A segunda estrutura também não é. Veja:</p>
<ul>
<li>Nível 0: 42. Ok. Está todo preenchido.</li>
<li>Nível 1: 28. Não está preenchido da esquerda para a direita.</li>
</ul>
<p>Por último, a terceira estrutura também não é quase-completa da esquerda para a direita.</p>
<ul>
<li>Nível 0: 93. Ok. Está todo preenchido.</li>
<li>Nível 1: 74 e 67. Ok. Está todo preenchido.</li>
<li>Nível 2: Não está todo preenchido da esquerda para a direita. Falta um nó à direita de 74. Por isso não é quase-completa da esquerda para a direita.</li>
<li>Nível 3: Está preenchido da esquerda para a direita, mas o nível anterior não. Por isso não está ok.</li>
</ul>
<h3 id="e-por-que-ser-completa-ou-quase-completa-é-importante">E por que ser completa ou quase-completa é importante?</h3>
<p>Você há de lembrar que boa parte das operações básicas fundamentais em árvores binárias são $\Theta(h)$, onde $h$ é a altura da árvore. Por isso, é preciso manter a altura próxima da altura mínima possível. Em uma árvore binária a altura mínima é $\Theta(\log n)$, certo?</p>
<p>Por isso a segunda propriedade de Heap é tão importante. Porque uma árvore completa ou quase-completa possui a altura $\Theta(\log n)$.</p>
<blockquote>
<p>Por construção, a altura de um Heap é $\Theta(\log n)$, pois é uma estrutura completa ou quase completa da esquerda para a direita. Essa propriedade permite que as operações de inserção e remoção sejam eficientes.</p>
</blockquote>
<p>Além disso, você pode estar se perguntando: e por que tem que ser quase-completa da esquerda para a direita? Porque isso facilita a implementação dessa estrutura de dados usando um array.</p>
<h1 id="implementação">Implementação</h1>
<p>Array? Nós havíamos implementado <a class="external" href="https://joaoarthurbm.github.io/eda/posts/bst">árvores binárias</a> utilizando nós, não? Sim, mas quem foi que disse que só tem uma maneira de fazer as coisas? Devido ao fato do Heap ser uma árvore completa ou quase-completa, somos capazes de utilizar um array para representá-lo.</p>
<h2 id="como-um-array-pode-representar-um-heap">Como um array pode representar um Heap?</h2>
<p>Nós vamos utilizar um array para implementar o Heap. Então, antes precisamos entender como os elementos dispostos em um array podem representar um Heap. Veja o exemplo abaixo:</p>
<figure style="align: center; margin-left:15%; width: 70%">
    <img src="heap-exemplo-menor.png">
</figure>
<p>O array que representa esse Heap é $heap = [48, 24, 45, 14]$. Como? Basta percorrer o Heap em largura e preencher o array. Ou seja, o índice 0 do array sempre será preenchido com a raiz, neste caso o valor 48. Depois, no índice 1, o array é preenchido com o valor 24. O índice 2 recebe o valor 45 e, por último, o índice 3 recebe o valor 14.</p>
<p>Mais um exemplo.</p>
<p><img src="heap-exemplo.png" alt="heap-exemplo"></p>
<p>O array que representa esse Heap é $heap = [88, 87, 73, 47, 54, 6, 0, 43]$. Como? Basta percorrer o Heap em largura e preencher o array. Ou seja, o índice 0 do array será preenchido com o valor 88. Depois, no índice 1, o array é preenchido com o valor 87. O índice 2 recebe o valor 73. Os índices 3 e 4 são preenchidos com os valores 47 e 54, respectivamente. Por último, os índices 5, 6 e 7 são preenchidos com os valores 6, 0 e 43, respectivamente.</p>
<h2 id="organização-interna-atributos-e-construtor">Organização Interna: atributos e construtor</h2>
<p>Em primeiro lugar, já dissemos que a representação do Heap será através de um array. Como temos que definir o tamanho do array de antemão e não sabemos quantos elementos o Heap irá conter, precisamos também ter um atributo (<em><strong>tail</strong></em>) que controla o índice do último elemento do array. Vejamos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Heap</span> <span style="color:#f92672">{</span>
    
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> heap<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> tail<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Heap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacidade<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>capacidade<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tail</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tail</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Veja que o que define a ocupação do array é o valor do atributo <em><strong>tail</strong></em>. O método isEmpty, por exemplo, compara esse valor com -1 para determinar se o Heap possui elementos ou não.</p>
<h2 id="left-right-e-parent">left, right e parent</h2>
<p>Para caminhar em uma árvore precisamos, a partir de um nó, acessar o nó à esquerda, o nó à direita e o nó pai. Na <a class="external" href="https://joaoarthurbm.github.io/eda/posts/bst">implementação de árvores binárias de pesquisa</a> nós utilizamos as referências <em><strong>left</strong></em>, <em><strong>right</strong></em> e <em><strong>parent</strong></em>. Contudo, como estamos utilizando um array para armazenar os elementos, precisamos implementar métodos que retornem a esquerda, a direita e o pai de um nó, baseado no seu índice.</p>
<p><em><strong>left</strong></em>. A esquerda de um nó no índice <em><strong>index</strong></em> sempre segue a fórmula $2*index + 1$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.</p>
<p><img src="heap-exemplo.png" alt="heap-exemplo"></p>
<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7</p>
<p>A raiz está no índice 0 do array. Portanto, o nó à sua esquerda está no índice 1, pois $2*0 + 1 = 1$.</p>
<p>O nó 87 está no índice 1 do array. Portanto, o nó à sua esquerda está no índice 3, pois $2*1 + 1 = 3$.</p>
<p>O nó 73 está no índice 2 do array. Portanto, o nó à sua esquerda está no índice 5, pois $2*2 + 1 = 5$.</p>
<p>O nó 47 está no índice 3 do array. Portanto, o nó à sua esquerda está no índice 7, pois $2*3 + 1 = 7$.</p>
<p>Os nós 54 (índice 4), 6 (índice 5), 0 (índice 6) e 43 (índice 7) não possuem esquerda, pois se aplicarmos a fórmula $2*index+1$ os valores gerados são índices maiores do que <em><strong>tail</strong></em> e, portanto, não fazem parte do Heap.</p>
<p><em><strong>right</strong></em>. A direita de um nó no índice <em><strong>index</strong></em> sempre segue a fórmula $2*(index + 1)$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.</p>
<p><img src="heap-exemplo.png" alt="heap-exemplo"></p>
<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7</p>
<p>A raiz está no índice 0 do array. Portanto, o nó à sua direita está no índice 2, pois $2*(0 + 1) = 2$.</p>
<p>O nó 87 está no índice 1 do array. Portanto, o nó à sua direita está no índice 4, pois $2*(1 + 1) = 4$.</p>
<p>O nó 73 está no índice 2 do array. Portanto, o nó à sua direita está no índice 6, pois $2*(2 + 1) = 6$.</p>
<p>O restante dos nós, índices 3, 4, 5, 6 e 7, não possuem direita, pois se aplicarmos a fórmula $2*(index+1)$ os valores gerados são índices maiores do que ***tail*** e, portanto, não fazem parte do Heap.</p>
<p><em><strong>parent</strong></em>. O pai de um nó no índice <em><strong>index</strong></em> sempre segue a fórmula $int((index-1)/2))$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.</p>
<p><img src="heap-exemplo.png" alt="heap-exemplo"></p>
<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7</p>
<p>A raiz está no índice 0 do array. Portanto, não possui nó pai, pois $int((0-1)/2)) = -1$, que é um índice inexistente.</p>
<p>Os nós 87 e 73 estão nos índices 1 e 2, respectivamente.Portanto, o nó pai está no índice 0, pois $int((1-1)/2)) = 0$ e $int((2-1)/2)) = 0$.</p>
<p>Os nós 47 e 54 estão nos índices 3 e 4, respectivamente. Portanto, o nó pai está no índice 1, pois $int((3-1)/2)) = 1$ e $int((4-1)/2)) = 1$.</p>
<p>Os nós 6 e 0 estão nos índices 5 e 6, respectivamente. Portanto, o nó pai está no índice 2, pois $int((5-1)/2)) = 2$ e $int((5-1)/2)) = 2$.</p>
<p>Por fim, o nó 43 no índice 7 do array. O nó pai está no índice 2, pois $int((7-1)/2)) = 3$.</p>
<p>Abaixo estão os métodos left, right e parent da classe Heap.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Heap</span> <span style="color:#f92672">{</span>    
<span style="color:#f92672">...</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">left</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> 2 <span style="color:#f92672">*</span> index <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">right</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> 2 <span style="color:#f92672">*</span> <span style="color:#f92672">(</span>index <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">parent</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>index<span style="color:#f92672">-</span>1<span style="color:#f92672">)/</span>2<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="inserção">Inserção</h2>
<p>Primeiro vamos entender o conceito visualmente, depois passamos para o código, ok? 
Suponha que inicialmente nós criamos um array de 10 posições e o Heap armazenado nesse array é o da figura abaixo.</p>
<p><img src="heap-exemplo.png" alt="heap-exemplo"></p>
<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43, 0, 0]$ e tail = 7</p>
<p>Note que os elementos que compõe o Heap estão entre os índices 0 e <em><strong>tail</strong></em>. Os índices 8 e 9 estão preenchidos com 0 porque é o valor default de Java. Nós tratamos essas posições como livres para serem adicionados novos elementos. Para reforçar: quem define os limites dos elementos presentes no Heap são 0 e <code>tail</code>.</p>
<p>Agora, atenção:</p>
<pre>
    A adição de um novo elemento sempre é feita na próxima 
    posição livre do array, isto é, tail + 1. Essa estratégia
    garante que o Heap sempre será completo ou quase completo
    da esquerda para a direita.
</pre>
<p>Então vamos adicionar o valor 100 ao Heap. Como dissemos, a adição é feita em tail + 1. Neste momento, o Heap e o array assumem os seguintes estados.</p>
<p><img src="animacao1.png" alt="animacao1"></p>
<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43, 100, 0]$ e tail = 8</p>
<p>Temos um problema aqui, certo? O fato de adicionarmos sempre na próxima posição livre garante que nunca vamos quebrar a propriedade de ser completa ou quase-completa da esquerda para a direita. No entanto, 100 é um valor maior que o valor do nó pai (47). Isso fere a restrição da Propriedade 1, que estabelece que todo nó deve ser maior que seus filhos. A ideia geral para resolver esse problema é comparar 100 com seu pai e, caso ele seja maior, trocar os dois de posição. Isso deve ser feito enquanto 100 for menor do que o pai ou 100 chegar na raiz.</p>
<p>Vamos ver como isso é feito passo a passo. Na primeira comparação, como 100 é maior que 47, há a troca desses valores, como ilustrado na figura abaixo. Perceba também que o array é modificado.</p>
<p><img src="animacao2.png" alt="animacao2"></p>
<p align="center">$heap = [88, 87, 73, 100, 54, 6, 0, 43, 47, 0]$ e tail = 8</p>
<p>O problema ainda persiste, pois 100, quando comparado com o nó pai (87) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.</p>
<p><img src="animacao3.png" alt="animacao3"></p>
<p align="center">$heap = [88, 100, 73, 87, 54, 6, 0, 43, 47, 0]$ e tail = 8</p>
<p>O problema ainda persiste, pois 100, quando comparado com o nó pai (88) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.</p>
<p><img src="animacao4.png" alt="animacao4"></p>
<p align="center">$heap = [100, 88, 73, 87, 54, 6, 0, 43, 47, 0]$ e tail = 8</p>
<p>Feito! Como 100 passou a ser a raiz, a inserção é finalizada.</p>
<p>Mais um exemplo? Vamos adicionar o elemento 90. Lembrando, a inserção sempre é feita em tail + 1. Então temos o Heap e seu array com o seguinte estado.</p>
<p><img src="animacao5.png" alt="animacao5"></p>
<p align="center">$heap = [100, 88, 73, 87, 54, 6, 0, 43, 47, 90]$ e tail = 9</p>
<p>Comparando 90 com o nó pai, temos que 90 &gt; 54 e, portanto, precisamos trocar esse valor. Feito isso, temos o seguinte cenário.</p>
<p><img src="animacao6.png" alt="animacao6"></p>
<p align="center">$heap = [100, 88, 73, 87, 90, 6, 0, 43, 47, 54]$ e tail = 9</p>
<p>O problema ainda persiste, pois 90, quando comparado com o nó pai (88) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.</p>
<p><img src="animacao7.png" alt="animacao7"></p>
<p align="center">$heap = [100, 90, 73, 87, 88, 6, 0, 43, 47, 54]$ e tail = 9</p>
<p>Feito! Como 90 é menor do que o nó pai (100), a inserção é finalizada.</p>
<p>Agora que já entendemos como o algoritmo funciona, vamos ao código.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tail <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span>heap<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">))</span>
        resize<span style="color:#f92672">();</span>

    tail <span style="color:#f92672">+=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>tail<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>parent<span style="color:#f92672">(</span>i<span style="color:#f92672">)]</span> <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>parent<span style="color:#f92672">(</span>i<span style="color:#f92672">)];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>parent<span style="color:#f92672">(</span>i<span style="color:#f92672">)]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">;</span>
        i <span style="color:#f92672">=</span> parent<span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>O primeiro if (<code>tail &gt;= heap.length - 1</code>) verifica se ainda há espaço no array para adicionar um novo elemento. Se não houver, o método <em><strong>resize</strong></em> é invocado. Ele apenas cria um array maior e copia os elementos para esse novo array.</p>
<p>Após a criação de um array maior, se necessário, incrementamos tail (<code>tail += 1</code>) e adicionamos o novo elemento no array (<code>this.heap[tail] = n</code>).</p>
<p>Agora vamos à rotina de comparar com o valor do nó pai enquanto for maior ou não atingir a raiz. Isso é feito no bloco do while. Caso essas duas condições forem satisfeitas, troca-se os valores do nó e do pai e atualiza o índice do elemento a ser verificado na próxima iteração (<code>i = parent(i)</code>).</p>
<h3 id="eficiência-do-método-de-inserção">Eficiência do método de inserção</h3>
<p>No pior caso, o elemento adicionado é o maior elemento do Heap e, por isso, temos que subir até a raiz. Nesse pior caso, o caminho percorrido é igual ao tamanho da altura, que sempre é $O(\log n)$ porque o Heap é completo ou quase-completo da esquerda para a direita.</p>
<blockquote>
<p>A inserção de um elemento no Heap é $O(\log n)$</p>
</blockquote>
<h2 id="remoção-e-heapify">Remoção e Heapify</h2>
<p>A remoção em um Heap não é parametrizada. O elemento removido sempre é o maior, ou seja, sempre a raiz.</p>
<blockquote>
<p>A remoção em um heap é sempre feita na raiz.</p>
</blockquote>
<p>Para manter a propriedade de ser completo ou quase-completo da esquerda para a direita, trocamos o valor da raiz com a última folha e removemos essa última folha. Note que, por ser um array, não removemos de fato a posição, apenas atualizamos tail (<code>tail = tail - 1</code>).</p>
<p>Vamos visualizar esse processo para o Heap abaixo.</p>
<p><img src="remocao1.png" alt="remocao1"></p>
<p align="center">$heap = [100, 90, 73, 87, 88, 6, 0, 43, 47, 54]$ e tail = 9</p>
<p>O primeiro passo então, é trocar a raíz (<code>this.heap[0]</code>) pela última folha (<code>this.heap[tail]</code>). No nosso exemplo, isso significa que 54 passa a ser a raiz.</p>
<p><img src="remocao2.png" alt="remocao2"></p>
<p align="center">$heap = [54, 90, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 9</p>
<p>Agora decrementamos o valor de tail <em><strong>tail</strong></em> (<code>tail -= 1</code>). O Heap fica nesse estado:</p>
<p><img src="remocao3.png" alt="remocao3"></p>
<p align="center">$heap = [54, 90, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 8</p>
<p>Temos um problema, certo? 54 é menor que o valor à sua esquerda e que o valor à sua direita. O que vamos fazer a partir de agora é resolver esse problema. E isso tem nome: <strong>heapify</strong>.</p>
<p>A ideia geral é comparar 54 com o filho à esquerda e o filho à direita. O maior dos três assume a posição de 54. Se o maior dos 3 for 54, o algoritmo não precisa seguir adiante. Vamos lá.</p>
<p>Comparando 54, 90 e 73, o maior valor é 90. Portanto, trocamos 90 com 54.</p>
<p><img src="remocao4.png" alt="remocao4"></p>
<p align="center">$heap = [90, 54, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 8</p>
<p>Novamente, comparamos 54 com o filho à esquerda e o filho à direita. O maior dos três assume a posição de 54. Ou seja, trocamos 54 por 88.</p>
<p><img src="remocao5.png" alt="remocao5"></p>
<p align="center">$heap = [90, 88, 73, 87, 54, 6, 0, 43, 47, 100]$ e tail = 8</p>
<p>Feito! 54 não possui mais filhos e, portanto, o algoritmo para.</p>
<p>Agora que já entendemos como o algoritmo funciona, vamos às particularidades do código aos poucos. Primeiro, a ideia geral do método <em><strong>remove()</strong></em>, que outros autores também chamam de <em><strong>extractMax()</strong></em>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">remove</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Empty&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> element <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>tail<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tail</span> <span style="color:#f92672">-=</span> 1<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heapify</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        
        <span style="color:#66d9ef">return</span> element<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>Esse código implementa o que discutimos. Primeiro, armazena a raiz em uma variável temporária para poder retornar (<code>element = this.heap[0]</code>). Depois, coloca na raiz o valor presente na última folha (<code>this.heap[0] = this.heap[tail]</code>) e diminui o tamanho do heap (<code>this.tail -= 1</code>) para poder iniciar o <em><strong>heapify</strong></em> a partir dela (<code>heapify(0)</code>).</p>
<p>E o <em><strong>heapify</strong></em>?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapify</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isLeaf<span style="color:#f92672">(</span>index<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>isValidIndex<span style="color:#f92672">(</span>index<span style="color:#f92672">))</span> 
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        
        <span style="color:#75715e">// compares index, left and right to find max
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> index_max <span style="color:#f92672">=</span> max_index<span style="color:#f92672">(</span>index<span style="color:#f92672">,</span> left<span style="color:#f92672">(</span>index<span style="color:#f92672">),</span> right<span style="color:#f92672">(</span>index<span style="color:#f92672">));</span>
        
        <span style="color:#75715e">// if current index is not greater than its children, 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// swap and keep heapifying.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index_max <span style="color:#f92672">!=</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                swap<span style="color:#f92672">(</span>index<span style="color:#f92672">,</span> index_max<span style="color:#f92672">);</span>
                heapify<span style="color:#f92672">(</span>index_max<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>  
<span style="color:#f92672">...</span>
</code></pre></div><p>O primeiro passo é verificar as condições de parada. Isso significa checar se o índice passado como parâmetro é uma folha ou está fora dos limites do Heap. Nesses dois casos não há a necessidade de efetuar o heapify.</p>
<p>Se houver a necessidade, comparamos index com left e right para determinar qual é o máximo entre eles. Isso é feito pelo método <em><strong>max_index</strong></em>.</p>
<p>Se o máximo entre eles for o próprio index, o algoritmo para. Caso contrário, trocamos index pelo máximo (<code>swap(index, index_max)</code>) e continuamos a efetuar o heapify a partir do índice que armazenava o máximo (<code>heapify(index_max)</code>).</p>
<p>Abaixo estão as implementações dos métodos auxiliares <em><strong>max_index, isValidIndex, isLeaf</strong></em> e <em><strong>swap</strong></em>. Como dito anteriormente, o método max_index compara os valores em index, left e right para identificar o maior deles. Você vai notar que há algumas verificações relacionadas à validade dos índices, uma vez que o índice deve estar dentro do intervalo $[0, tail]$.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">max_index</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> left<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> right<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>left<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isValidIndex<span style="color:#f92672">(</span>right<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>right<span style="color:#f92672">])</span>
                    <span style="color:#66d9ef">return</span> right<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
           
            <span style="color:#66d9ef">return</span> index<span style="color:#f92672">;</span>
        
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isValidIndex<span style="color:#f92672">(</span>right<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>left<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>right<span style="color:#f92672">])</span>
                    <span style="color:#66d9ef">return</span> right<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> 
            
            <span style="color:#66d9ef">return</span> left<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isValidIndex</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> index <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">&lt;=</span> tail<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isLeaf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> index <span style="color:#f92672">&gt;</span> parent<span style="color:#f92672">(</span>tail<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">&lt;=</span> tail<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> 
    
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><h3 id="eficiência-do-método-de-remoção">Eficiência do método de remoção</h3>
<p>No pior caso o heapify é executado até o nível das folhas. Nesse pior caso, o caminho percorrido é igual ao tamanho da altura, que sempre é $O(\log n)$ porque o Heap é completo ou quase-completo da esquerda para a direita.</p>
<blockquote>
<p>A remoção de um elemento no Heap é $O(\log n)$</p>
</blockquote>
<h2 id="build-heap">Build Heap</h2>
<p>Nem todo array representa um Heap, certo? Por exemplo, o array $a = [40, 87, 2, 90, 1, 100, 30, 20]$ não representa um Heap porque nem todo nó é maior do que os nós à esquerda e à direita, como ilustrado na figura abaixo.</p>
<p><img src="build-heap1.png" alt="build-heap1"></p>
<p>O nosso desafio agora é transformar essa estrutura em um Heap. A ideia é aplicar sucessivas vezes o algoritmo <em><strong>heapify</strong></em>, discutido na seção anterior.</p>
<p>Nós começamos pelo pai da última folha. Por que? Porque a aplicação do heapify nas folhas é inútil, já que uma folha já respeita as propriedade de Heap.</p>
<p>Então, para o exemplo acima, vamos aplicar primeiro heapify no índice 3, que armazena o valor 90. Depois, vamos aplicar em todos os índices menores que 3 até a raiz, ou seja, heapify(2), heapify(1) e heapify(0). Ao final desse processo o array representará um Heap.</p>
<p>Vamos acompanhar passo a passo esse algoritmo. A primeira execução do heapify é no índice 3, que armazena 90. Como 90 é maior que o seu único filho, nada é feito. Depois aplicamos o heapify no índice 2, que armazena o valor 2. O heapify então compara 2, 100 e 30. Como 100 é maior, há a troca de valores entre 100 e 2. O resultado parcial até agora é o seguinte.</p>
<p><img src="build-heap2.png" alt="build-heap2"></p>
<p>Agora falta aplicar no índice 1 e 0. Aplicando heapify no índice 1, o algoritmo compara 87 com 90 e 1. Como 90 é maior, há a troca de valores entre 90 e 87. Depois disso, 87 é comparado com 20. Como é maior, o algoritmo para. Até aqui, temos o seguinte cenário.</p>
<p><img src="build-heap3.png" alt="build-heap3"></p>
<p>Por fim, falta apenas a última aplicação de heapify. Isso é feito no índice 0, ou seja, na raiz.O resultado final é ilustrado abaixo.</p>
<p><img src="build-heap4.png" alt="build-heap4"></p>
<p>Em resumo, para construir um Heap a partir de um array qualquer basta aplicar <em><strong>heapify</strong></em> partindo do índice do pai da última folha até a raiz. O código abaixo implementa essa rotina.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">...</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Heap</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> heap<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span> <span style="color:#f92672">=</span> heap<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tail</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">heap</span><span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">buildHeap</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildHeap</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> parent<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">tail</span><span style="color:#f92672">);</span> i <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span>
            heapify<span style="color:#f92672">(</span>i<span style="color:#f92672">);</span> 
    <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><hr>
<h1 id="resumo">Resumo</h1>
<ul>
<li>
<p>Heap é uma árvore binária.</p>
</li>
<li>
<p>Todos os nós presentes no Heap são maiores que os seus nós à esquerda e à direita. Isso quer dizer que o maior valor sempre está na raiz.</p>
</li>
<li>
<p>Heap é uma árvore completa ou quase-completa da esquerda para a direita. Esta propriedade garante que a altura da árvore é sempre a mínima possível, ou seja, $O(\log n)$.</p>
</li>
<li>
<p>Esta última propriedade garante inserção e remoção em $O(\log n)$.</p>
</li>
<li>
<p>Heap é uma excelente alternativa para implementação de filas de prioridade.</p>
</li>
<li>
<p>Por ser completo ou quase-completo da esquerda para a direita, podemos implementar Heaps em arrays, ao invés de nós ligados.</p>
</li>
<li>
<p>O array que representa um Heap é o resultado do seu percurso em largura. Ou seja, a raiz sempre está no índice 0. Nos índices 1 e 2 estão os elementos do nível 1. Nos índices 3, 4, 5 e 6 estão os elementos do nível 2 e assim por diante.</p>
</li>
<li>
<p>Os métodos left, right e parent são implementados de acordo com os índices dos elementos no array. A esquerda de um nó no índice <em><strong>i</strong></em> é dada por $2<em>i+1$. A direita de um nó no índice <em><strong>i</strong></em> é dada por $2</em>(i+1)$. O pai de um nó no índice <em><strong>i</strong></em> é dados por $int((index - 1) / 2)$.</p>
</li>
<li>
<p>A adição de um elemento é sempre feita na próxima posição livre do array. Depois de adicionado, deve-se comparar o elemento com o pai. Se o seu valor foi maior, troca-se os elementos. Esse processo é feito enquanto o valor for maior ou não chegar na raiz.</p>
</li>
<li>
<p>O elemento removido sempre é o maior, isto é, a raiz. Antes disso, colocamos o valor da última folha na raiz e executamos o heapify.</p>
</li>
<li>
<p>Heapify é uma rotina que compara um nó, a sua esquerda e a sua direita. O maior dos três deve ser a raiz dessa sub-arvore. Caso o maior dos três seja o próprio nó, o algoritmo para. Caso contrário, segue a comparação árvore abaixo.</p>
</li>
<li>
<p>Para construir um Heap a partir de um array qualquer, basta executar o heapify seguidas vezes. Partindo o pai da última folha até a raiz. Esse método se chama <em><strong>Build Heap</strong></em>.</p>
</li>
</ul>
<hr>
<h1 id="notas">Notas</h1>
<p>Utilizar uma ferramenta de visualização facilita muito o aprendizado das estruturas que estudamos. Para fazer as figuras deste material eu utilizei <a class="external" href="http://btv.melezinek.cz/binary-heap.html">esta ferramenta.</a> Também recomendo o <a class="external" href="https://visualgo.net/en">VisualAlgo</a>.</p>


</article>


<section class="post-nav">
    <ul>
        
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/bst/">Árvores Binárias de Pesquisa <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
    <h6><a href="http://joaoarthurbm.github.io">Copyright © 2019 - João Arthur Brunet</a></h6>
    </footer>
</div>
<script src="https://joaoarthurbm.github.io/eda/js/scripts.js"></script>

</body>

</html>

