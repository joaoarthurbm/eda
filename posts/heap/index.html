<!doctype html>

<html lang="en">

<head>
  <title>Estrutura de Dados</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="João Arthur Brunet" /><meta name="generator" content="Hugo 0.59.0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />
  <script src="https://kit.fontawesome.com/b76b73e8e8.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://joaoarthurbm.github.io/eda/css/styles.css" /><script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151903059-1"></script>
<script>
      window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

            gtag('config', 'UA-151903059-1');
        </script>


</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://joaoarthurbm.github.io/eda/">Estrutura de Dados</a>
            </h1>

      <ul id="social-media">
        
        
        
        <li><a href="https://twitter.com/joaobrunet"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="http://joaoarthurbm.github.io"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
           
        <li><a href="https://instagram.com/joaoarthurbm"><i class="fab fa-instagram fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>João Arthur Brunet - Computação @ UFCG</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/about/">
                <i class="fa-li fa  fa-lg"></i><span>Conteúdo</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/contribua/">
                <i class="fa-li fa  fa-lg"></i><span>Contribua</span>
            </a>
        </li>
        
    </ul>
</nav>
    <main>




<article>

    <h1>Heap</h1>    

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-10-22T00:00:00-03:00">Oct 22, 2019</time>
        </li>
        

        

        <li>20 minutes read</li>

        


    </ul>
</aside>

    

    

<p>(ainda sob construção&hellip;)</p>

<hr />

<p>Nem toda fila segue a política de acesso <em>First In First Out</em> (FIFO). Na verdade, em vários cenários do dia a dia, as filas que entramos possuem uma política diferente: são filas de prioridade. Por exemplo, mesmo que um adolescente chegue antes de um idoso na fila do banco, é provável que o idoso seja atendido primeiro porque ele tem, por lei (e deveria ter por civilidade também), <strong>prioridade</strong> no atendimento.</p>

<p>No contexto de estrutura de dados, precisamos pensar em como manter a estrutura ordenada tendo como critério essa prioridade. Então, vamos primeiro analisar alternativas para implementar filas de prioridade usando estruturas de dados lineares, como <a class="external" href="https://joaoarthurbm.github.io/eda/posts/linkedlist/">LinkedList</a> ou <a class="external" href="https://joaoarthurbm.github.io/eda/posts/arraylist/">ArrayList</a>.
Em primeiro lugar, os objetos passam a ter uma prioridade, que é representada por um atributo inteiro. No nosso exemplo, quanto maior esse número, maior a prioridade. Nesse caso, para implementarmos uma fila de prioridade, temos que tomar uma decisão:  manter a fila ordenada ou não?</p>

<p>Se decidirmos manter a fila sempre ordenada tendo como critério a prioridade, precisamos utilizar o algoritmo de inserção ordenada, cujo custo é $O(n)$. Contudo, a extração do maior elemento é ${O(1)}$, pois ele sempre está no início da fila.</p>

<p>Se optarmos por não mater a fila ordenada por prioridade, temos o cenário oposto. A adição passa a ser $O(1)$, mas a remoção do maior passa a ser $O(n)$, pois teremos que pesquisar em toda a fila a maior prioridade.</p>

<p>Em resumo, temos de um lado adição $O(n)$ e remoção $O(1)$ e do outro lado temos adição $O(1)$ e remoção $O(n)$.</p>

<p>A estrutura que veremos neste material, <em>Heap</em>, resolve essa questão permitindo que a adição e extração do máximo sejam ambas realizadas em $O(\log n)$, o que é muito desejável do ponto de vista de eficiência. Além disso, o máximo fica sempre na raiz dessa estrutura, o que permite sua inspeção em $O(1)$.</p>

<hr />

<h1 id="definições-e-propriedades">Definições e Propriedades</h1>

<p><em>Heaps</em> são árvores binárias. É importante deixar claro desde já que são árvores binárias, mas não são árvores binárias de pesquisa. Mais especificamente, duas propriedades definem o Heap:</p>

<pre>
1. O valor de um nó é maior ou igual ao valor de seus filhos;

2. O Heap é uma árvore binária completa ou quase-completa 
da esquerda para a direita.
</pre>

<p><strong>Propriedade 1.</strong> A primeira propriedade é a que difere um Heap de uma árvore binária de pesquisa (BST). Na BST, os valores à esquerda de um nó são menores do que ele e os valores à direita são maiores. No Heap, ambos são menores ou iguais. Heaps que seguem essa propriedade são Heaps Máximos porque o maior valor sempre está na raiz. Há também Heaps Mínimos, onde o nó tem valor sempre menor ou igual ao seus filhos. Neste caso, o menor valor sempre está na raiz. Neste material, vamos utilizar o termo Heap como sinônimo de Heap Máximo.</p>

<p><strong>Propriedade 2.</strong> Se você leu o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/bst">material de árvores binárias de pesquisa</a>, você já sabe o que quer dizer uma árvore completa, certo? Mas,</p>

<p align="center">o que quer dizer <i>quase-completa da esquerda para a direita?</i></p>

<p>Quer dizer que, se ela não for completa, todos os níveis estão preenchidos, exceto o último, que deve estar preenchido da esquerda para a direita até um certo ponto. Vamos ver exemplos de Heaps e Não-Heaps para esclarecer esse conceito.</p>

<p>Para exemplos de Heaps, vamos analisar a figura abaixo. Perceba que, além de satisfazerem a propriedade 1, todas as estruturas são completas ou quase-completas da esquerda para a direita e, portanto, são Heaps.</p>

<p><img src="heaps.png" alt="heaps" /></p>

<p>A primeira estrutura possui 3 níveis:</p>

<ul>
<li>Nível 0: 92</li>
<li>Nível 1: 92 e 6</li>
<li>Nível 2: 48 e 70</li>
</ul>

<p>O nível 0 e o nível 1 estão completamente preenchidos. O único nível que não está preenchido é o último, mas ele está parcialmente preenchido da esquerda para a direita (46 e 70). Note que não há &ldquo;salto&rdquo; ao percorrer a estrutura em largura. Por isso, essa estrutura é um Heap.</p>

<p>A segunda estrutura é um Heap porque respeita a primeira propriedade e é uma árvore binária completa.</p>

<p>A terceira estrutura é um Heap porque respeita a primeira propriedade e é quase-completa da esquerda para a direita. Novamente, todos os níveis exceto o último estão completamente preenchidos e o último nível está parcialmente preenchido da esquerda para a direita:</p>

<ul>
<li>Nível 0: 93</li>
<li>Nível 1: 74 e 67</li>
<li>Nível 2: 63, 53, 16 e 41</li>
<li>Nível 3: 5, 3, 25 e 10 (parcialmente preenchido da esquerda para a direita)</li>
</ul>

<p>Note que, se removessemos o 25 dessa estrutura, ela não seria mais um Heap, pois o último nível não estaria preenchido da esquerda para a direita. Haveria um salto entre 3 e 10.</p>

<p>Agora, para fixar bem, vamos ver exemplos de estruturas que não são completas ou quase-completas da esquerda para a direita e, portanto, não são Heaps.</p>

<p><img src="nao-heaps.png" alt="nao-heaps" /></p>

<p>Em primeiro lugar, nenhuma das estruturas acima é completa. Agora precisamos checar se são quase-completas da esquerda para a direita.</p>

<p>A primeira estrutura não é quase-completa da esquerda para a direita. Veja:</p>

<ul>
<li>Nível 0: 92. Ok. Está todo preenchido.</li>
<li>Nível 1: 92. Não está todo preenchido. Por isso não é quase-completa da esquerda para a direita.</li>
<li>Nível 2: 48 e 70. Está preenchido da esquerda para a direita, mas o nível anterior não. Por isso não está ok.</li>
</ul>

<p>A segunda estrutura também não é. Veja:</p>

<ul>
<li>Nível 0: 42. Ok. Está todo preenchido.</li>
<li>Nível 1: 28. Não está preenchido da esquerda para a direita.</li>
</ul>

<p>Por último, a terceira estrutura também não é quase-coompleta da esquerda para a direita.</p>

<ul>
<li>Nível 0: 93. Ok. Está todo preenchido.</li>
<li>Nível 1: 74 e 67. Ok. Está todo preenchido.</li>
<li>Nível 2: Não está todo preenchido da esquerda para a direita. Falta um nó à direita de 74. Por isso não é quase-completa da esquerda para a direita.</li>
<li>Nível 3: Está preenchido da esquerda para a direita, mas o nível anterior não. Por isso não está ok.</li>
</ul>

<h3 id="e-por-que-ser-completa-ou-quase-completa-é-importante">E por que ser completa ou quase-completa é importante?</h3>

<p>Você há de lembrar que boa parte das operações básicas fundamentais em árvores binárias são $\Theta(h)$, onde $h$ é a altura da árvore. Por isso, é preciso manter a altura próxima da altura mínima possível. Em uma árvore binária a altura mínima é $\Theta(\log n)$, certo?</p>

<p>Por isso a segunda propriedade de Heap é tão importante. Porque uma árvore completa ou quase-completa possui a altura $\Theta(\log n)$.</p>

<blockquote>
<p>Por construção, a altura de um Heap é $\Theta(\log n)$, pois é uma estrutura completa ou quase completa da esquerda para a direita. Essa propriedade permite que as operações de inserção e remoção sejam eficientes.</p>
</blockquote>

<p>Além disso, você pode estar se perguntando: e por que tem que ser quase-completa da esquerda para a direita? Porque isso facilita a implementação dessa estrutura de dados usando um array.</p>

<h1 id="implementação">Implementação</h1>

<p>Array? Nós havíamos implementado <a class="external" href="https://joaoarthurbm.github.io/eda/posts/bst">árvores binárias</a> utilizando nós, não? Sim, mas quem foi que disse que só tem uma maneira de fazer as coisas? Devido ao fato do Heap ser uma árvore completa ou quase-completa, somos capazes de utilizar um array para representá-lo.</p>

<h2 id="como-um-array-pode-representar-um-heap">Como um array pode representar um Heap?</h2>

<p>Nós vamos utilizar um array para implementar o Heap. Então, antes precisamos entender como os elementos dispostos em um array podem representar um Heap. Veja o exemplo abaixo:</p>

<p><img src="heap-exemplo-menor.png" alt="heap-exemplo-menor" /></p>

<p>O array que representa esse Heap é $heap = [48, 24, 45, 14]$. Como? Basta percorrer o Heap em largura e preencher o array. Ou seja, o índice 0 do array sempre será preenchido com a raiz, neste caso o valor 48. Depois, no índice 1, o array é preenchido com o valor 24. O índice 2 recebe o valor 45 e, por último, o índice 3 recebe o valor 14.</p>

<p>Mais um exemplo.</p>

<p><img src="heap-exemplo.png" alt="heap-exemplo" /></p>

<p>O array que representa esse Heap é $heap = [88, 87, 73, 47, 54, 6, 0, 43]$. Como? Basta percorrer o Heap em largura e preencher o array. Ou seja, o índice 0 do array será preenchido com o valor 88. Depois, no índice 1, o array é preenchido com o valor 87. O índice 2 recebe o valor 73. Os índices 3 e 4 são preenchidos com os valores 47 e 54, respectivamente. Por último, os índices 5, 6 e 7 são preenchidos com os valores 6, 0 e 43, respectivamente.</p>

<h2 id="organização-interna-atributos-e-construtor">Organização Interna: atributos e construtor</h2>

<p>Em primeiro lugar, já dissemos que a representação do Heap será através de um array. Como temos que definir o tamanho do array de antemão e não sabemos quantos elementos o Heap irá conter, precisamos também ter um atributo (<strong><em>tail</em></strong>) que controla o índice do último elemento do array. Vejamos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">class</span> Heap {
    
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">int</span>[] heap;
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">int</span> tail;
    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Heap</span>(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">capacidade</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[capacidade];
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">tail</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
    }
    
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">boolean</span> isEmpty() {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">tail</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1;
    }
    ...
}</code></pre></div>
<p>Veja que o que define a ocupação do array é o valor do atributo <strong><em>tail</em></strong>. O método isEmpty, por exemplo, compara esse valor com -1 para determinar se o Heap possui elementos ou não.</p>

<h2 id="left-right-e-parent">left, right e parent</h2>

<p>Para caminhar em uma árvore precisamos, a partir de um nó, acessar o nó à esquerda, o nó à direita e o nó pai. Na <a class="external" href="https://joaoarthurbm.github.io/eda/posts/bst">implementação de árvores binárias de pesquisa</a> nós utilizamos as referências <strong><em>left</em></strong>, <strong><em>right</em></strong> e <strong><em>parent</em></strong>. Contudo, como estamos utilizando um array para armazenar os elementos, precisamos implementar métodos que retornem a esquerda, a direita e o pai de um nó, baseado no seu índice.</p>

<p><strong><em>left</em></strong>. A esquerda de um nó no índice <strong><em>index</em></strong> sempre segue a fórmula $2*index + 1$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.</p>

<p><img src="heap-exemplo.png" alt="heap-exemplo" /></p>

<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7</p>

<p>A raiz está no índice 0 do array. Portanto, o nó à sua esquerda está no índice 1, pois $2*0 + 1 = 1$.</p>

<p>O nó 87 está no índice 1 do array. Portanto, o nó à sua esquerda está no índice 3, pois $2*1 + 1 = 3$.</p>

<p>O nó 73 está no índice 2 do array. Portanto, o nó à sua esquerda está no índice 5, pois $2*2 + 1 = 3$.</p>

<p>O nó 47 está no índice 3 do array. Portanto, o nó à sua esquerda está no índice 7, pois $2*3 + 1 = 7$.</p>

<p>Os nós 54 (índice 4), 6 (índice 5), 0 (índice 6) e 43 (índice 7) não possuem esquerda, pois se aplicarmos a fórmula $2*index+1$ os valores gerados são índices maiores do que <strong><em>tail</em></strong> e, portanto, não fazem parte do Heap.</p>

<p><strong><em>right</em></strong>. A direita de um nó no índice <strong><em>index</em></strong> sempre segue a fórmula $2*(index + 1)$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.</p>

<p><img src="heap-exemplo.png" alt="heap-exemplo" /></p>

<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7</p>

<p>A raiz está no índice 0 do array. Portanto, o nó à sua direita está no índice 2, pois $2*(0 + 1) = 2$.</p>

<p>O nó 87 está no índice 1 do array. Portanto, o nó à sua direita está no índice 4, pois $2*(1 + 1) = 4$.</p>

<p>O nó 73 está no índice 2 do array. Portanto, o nó à sua esquerda está no índice 6, pois $2*(2 + 1) = 3$.</p>

<p>O restante dos nós, índices 3, 4, 5, 6 e 7, não possuem direita, pois se aplicarmos a fórmula $2*(index+1)$ os valores gerados são índices maiores do que <strong><em>tail</em></strong> e, portanto, não fazem parte do Heap.</p>

<p><strong><em>parent</em></strong>. O pai de um nó no índice <strong><em>index</em></strong> sempre segue a fórmula $int((index-1)/2))$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.</p>

<p><img src="heap-exemplo.png" alt="heap-exemplo" /></p>

<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7</p>

<p>A raiz está no índice 0 do array. Portanto, não possui nó pai, pois $int((0-1)/2)) = -1$, que é um índice inexistente.</p>

<p>Os nós 87 e 73 estão nos índices 1 e 2, respectivamente.Portanto, o nó pai está no índice 0, pois $int((1-1)/2)) = 0$ e $int((2-1)/2)) = 0$.</p>

<p>Os nós 47 e 54 estão nos índices 3 e 4, respectivamente. Portanto, o nó pai está no índice 1, pois $int((3-1)/2)) = 0$ e $int((4-1)/2)) = 1$.</p>

<p>Os nós 6 e 0 estão nos índices 5 e 6, respectivamente. Portanto, o nó pai está no índice 2, pois $int((5-1)/2)) = 2$ e $int((5-1)/2)) = 2$.</p>

<p>Por fim, o nó 43 no índice 7 do array. O nó pai está no índice 2, pois $int((7-1)/2)) = 3$.</p>

<p>Abaixo estão os métodos left, right e parent da classe Heap.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">class</span> Heap {    
...
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">int</span> left(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index</span>) {
        <span style="color:#66d9ef">return</span> 2 <span style="color:#f92672">*</span> index <span style="color:#f92672">+</span> 1;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">int</span> right(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index</span>) {
        <span style="color:#66d9ef">return</span> 2 <span style="color:#f92672">*</span> (index <span style="color:#f92672">+</span> 1);
    }

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">int</span> parent(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index</span>) {
        <span style="color:#66d9ef">return</span> (index<span style="color:#f92672">-</span>1)<span style="color:#f92672">/</span>2;
    }
...
}</code></pre></div>
<h2 id="inserção">Inserção</h2>

<p>Primeiro vamos entender o conceito visualmente, depois passamos para o código, ok?
Suponha que inicialmente nós criamos um array de 10 posições e o Heap armazenado nesse array é o da figura abaixo.</p>

<p><img src="heap-exemplo.png" alt="heap-exemplo" /></p>

<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43, 0, 0]$ e tail = 7</p>

<p>Note que os elementos que compõe o Heap estão entre os índices 0 e <strong><em>tail</em></strong>. Os índices 8 e 9 estão preenchidos com 0 porque é o valor default de Java. Nós tratamos essas posições como livres para serem adicionados novos elementos. Para reforçar: quem define os limites dos elementos presentes no Heap são 0 e <code>tail</code>.</p>

<p>Agora, atenção:</p>

<pre>
    A adição de um novo elemento sempre é feita na próxima 
    posição livre do array, isto é, tail + 1. Essa estratégia
    garante que o Heap sempre será completo ou quase completo
    da esquerda para a direita.
</pre>

<p>Então vamos adicionar o valor 100 ao Heap. Como dissemos, a adição é feita em tail + 1. Neste momento, o Heap e o array assumem os seguintes estados.</p>

<p><img src="animacao1.png" alt="animacao1" /></p>

<p align="center">$heap = [88, 87, 73, 47, 54, 6, 0, 43, 100, 0]$ e tail = 8</p>

<p>Temos um problema aqui, certo? O fato de adicionarmos sempre na próxima posição livre garante que nunca vamos quebrar a propriedade de ser completa ou quase-completa da esquerda para a direita. No entanto, 100 é um valor maior que o valor do nó pai (47). Isso fere a restrição da Propriedade 1, que estabelece que todo nó deve ser maior que seus filhos. A ideia geral para resolver esse problema é comparar 100 com seu pai e, caso ele seja maior, trocar os dois de posição. Isso deve ser feito enquanto 100 for menor do que o pai ou 100 chegar na raiz.</p>

<p>Vamos ver como isso é feito passo a passo. Na primeira comparação, como 100 é maior que 47, há a troca desses valores, como ilustrado na figura abaixo. Perceba também que o array é modificado.</p>

<p><img src="animacao2.png" alt="animacao2" /></p>

<p align="center">$heap = [88, 87, 73, 100, 54, 6, 0, 43, 47, 0]$ e tail = 8</p>

<p>O problema ainda persiste, pois 100, quando comparado com o nó pai (87) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.</p>

<p><img src="animacao3.png" alt="animacao3" /></p>

<p align="center">$heap = [88, 100, 73, 87, 54, 6, 0, 43, 47, 0]$ e tail = 8</p>

<p>O problema ainda persiste, pois 100, quando comparado com o nó pai (88) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.</p>

<p><img src="animacao4.png" alt="animacao4" /></p>

<p align="center">$heap = [100, 88, 73, 87, 54, 6, 0, 43, 47, 0]$ e tail = 8</p>

<p>Feito! Como 100 passou a ser a raiz, a inserção é finalizada.</p>

<p>Mais um exemplo? Vamos adicionar o elemento 90. Lembrando, a inserção sempre é feita em tail + 1. Então temos o Heap e seu array com o seguinte estado.</p>

<p><img src="animacao5.png" alt="animacao5" /></p>

<p align="center">$heap = [100, 88, 73, 87, 54, 6, 0, 43, 47, 90]$ e tail = 9</p>

<p>Comparando 90 com o nó pai, temos que 90 &gt; 54 e, portanto, precisamos trocar esse valor. Feito isso, temos o seguinte cenário.</p>

<p><img src="animacao6.png" alt="animacao6" /></p>

<p align="center">$heap = [100, 88, 73, 87, 90, 6, 0, 43, 47, 54]$ e tail = 9</p>

<p>O problema ainda persiste, pois 90, quando comparado com o nó pai (88) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.</p>

<p><img src="animacao7.png" alt="animacao7" /></p>

<p align="center">$heap = [100, 90, 73, 87, 88, 6, 0, 43, 47, 54]$ e tail = 9</p>

<p>Feito! Como 90 é menor do que o nó pai (100), a inserção é finalizada.</p>

<p>Agora que já entendemos como o algoritmo funciona, vamos ao código.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">...
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">void</span> add(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">n</span>) {
    <span style="color:#66d9ef">if</span> (tail <span style="color:#f92672">&gt;=</span> (heap.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1))
        resize();
    <span style="color:#66d9ef">else</span> {
        tail <span style="color:#f92672">+=</span> 1;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[tail] <span style="color:#f92672">=</span> n;
        
        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> tail;
        <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[parent(i)] <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[i]) {
            <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">aux</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[i];
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[parent(i)];
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[parent(i)] <span style="color:#f92672">=</span> aux;
            i <span style="color:#f92672">=</span> parent(i);
        }
    }
}
...</code></pre></div>
<p>O primeiro if (<code>tail &gt;= heap.length - 1</code>) verifica se ainda há espaço no array para adicionar um novo elemento. Se não houver, o método <strong><em>resize</em></strong> é invocado. Ele apenas cria um array maior e copia os elementos para esse novo array.</p>

<p>Caso haja espaço (<code>else</code>), incrementamos tail (<code>tail += 1</code>) e adicionamos o novo elemento no array (<code>this.heap[tail] = n</code>).</p>

<p>Agora vamos à rotina de comparar com o valor do nó pai enquanto for maior ou não atingir a raiz. Isso é feito no bloco do while. Caso essas duas codições forem satisfeitas, troca-se os valores do nó e do pai e atualiza o índice do elemento a ser verificado na próxima iteração (<code>i = parent(i)</code>).</p>

<h3 id="eficiência-do-método-de-inserção">Eficiência do método de inserção</h3>

<p>No pior caso, o elemento adicionado é o maior elemento do Heap e, por isso, temos que subir até a raiz. Nesse pior caso, o caminho percorrido é igual ao tamanho da altura, que sempre é $O(\log n)$ porque o Heap é completo ou quase-completo da esquerda para a direita.</p>

<blockquote>
<p>A inserção de um elemento no Heap é $O(\log n)$</p>
</blockquote>

<h2 id="remoção-e-heapify">Remoção e Heapify</h2>

<p>A remoção em um Heap não é parametrizada. O elemento removido sempre é o maior, ou seja, sempre a raiz.</p>

<blockquote>
<p>A remoção em um heap é sempre feita na raiz.</p>
</blockquote>

<p>Para manter a propriedade de ser completo ou quase-completo da esquerda para a direita, trocamos o valor da raiz com a última folha e removemos essa última folha. Note que, por ser um array, não removemos de fato a posição, apenas atualizamos tail (<code>tail = tail - 1</code>).</p>

<p>Vamos visualizar esse processo para o Heap abaixo.</p>

<p><img src="remocao1.png" alt="remocao1" /></p>

<p align="center">$heap = [100, 90, 73, 87, 88, 6, 0, 43, 47, 54]$ e tail = 9</p>

<p>O primeiro passo então, é trocar a raíz (<code>this.heap[0]</code>) pela última folha (<code>this.heap[tail]</code>). No nosso exemplo, isso significa que 54 passa a ser a raiz.</p>

<p><img src="remocao2.png" alt="remocao2" /></p>

<p align="center">$heap = [54, 90, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 9</p>

<p>Agora decrementamos o valor de tail <strong><em>tail</em></strong> (<code>tail -= 1</code>). O Heap fica nesse estado:</p>

<p><img src="remocao3.png" alt="remocao3" />
<p align="center">$heap = [54, 90, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 8</p></p>

<p>Temos um problema, certo? 54 é menor que o valor à sua esquerda e que o valor à sua direita. O que vamos fazer a partir de agora é resolver esse problema. E isso tem nome: <strong>heapify</strong>.</p>

<p>A ideia geral é comparar 54 com o filho à esquerda e o filho à direita. O maior dos três assume a posição de 54. Se o maior dos 3 for 54, o algoritmo não precisa seguir adiante. Vamos lá.</p>

<p>Comparando 54, 90 e 73, o maior valor é 90. Portanto, trocamos 90 com 54.</p>

<p><img src="remocao4.png" alt="remocao4" />
<p align="center">$heap = [90, 54, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 8</p></p>

<p>Novamente, comparamos 54 com o filho à esquerda e o filho à direita. O maior dos três assume a posição de 54. Ou seja, trocamos 54 por 88.</p>

<p><img src="remocao5.png" alt="remocao5" />
<p align="center">$heap = [90, 88, 73, 87, 54, 6, 0, 43, 47, 100]$ e tail = 8</p></p>

<p>Feito! 54 não possui mais filhos e, portanto, o algoritmo para.</p>

<p>Agora que já entendemos como o algoritmo funciona, vamos às particularidades do código aos poucos. Primeiro, a ideia geral do método <strong><em>remove()</em></strong>, que outros autores também chamam de <strong><em>extractMax()</em></strong>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">...
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">int</span> remove() {
        <span style="color:#66d9ef">if</span> (isEmpty()) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException(<span style="color:#e6db74">&#34;Empty&#34;</span>);
        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">element</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[0];
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[0] <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[tail];
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">tail</span> <span style="color:#f92672">-=</span> 1;

        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heapify</span>(0);
        
        <span style="color:#66d9ef">return</span> element;
    }
...</code></pre></div>
<p>Esse código implementa o que discutimos. Primeiro, armazena a raiz em uma variável temporária para poder retornar (<code>element = this.heap[0]</code>). Depois, coloca na raiz o valor presente na última folha (<code>this.heap[0] = this.heap[tail]</code>) e diminui o tamanho do heap (<code>this.tail -= 1</code>) para poder iniciar o <strong><em>heapify</em></strong> a partir dela (<code>heapify(0)</code>).</p>

<p>E o <strong><em>heapify</em></strong>?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">...
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">void</span> heapify(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index</span>) {
        <span style="color:#66d9ef">if</span> (isLeaf(index) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>isValidIndex(index)) 
            <span style="color:#66d9ef">return</span>;
        
        <span style="color:#75715e">// compares index, left and right to find max
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index_max</span> <span style="color:#f92672">=</span> max_index(index, left(index), right(index));
        
        <span style="color:#75715e">// if current index is not greater than its children, 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// swap and keep heapifying.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (index_max <span style="color:#f92672">!=</span> index) {
                swap(index, index_max);
                heapify(index_max);
        }
    }  
...</code></pre></div>
<p>O primeiro passo é verificar as condições de parada. Isso significa checar se o índice passado como parâmetro é uma folha ou está fora dos limites do Heap. Nesses dois casos não há a necessidade de efetuar o heapify.</p>

<p>Se houver a necessidade, comparamos index com left e right para determinar qual é o máximo entre eles. Isso é feito pelo método <strong><em>max_index</em></strong>.</p>

<p>Se o máximo entre eles for o próprio index, o algoritmo para. Caso contrário, trocamos index pelo máximo (<code>swap(index, index_max)</code>) e continuamos a efetuar o heapify a partir do índice que armazenava o máximo (<code>heapify(index_max)</code>).</p>

<p>Abaixo estão as implementações dos métodos auxiliares <strong><em>max_index, isValidIndex, isLeaf</em></strong> e <strong><em>swap</em></strong>. Como dito anteriormente, o método max_index compara os valores em index, left e right para identificar o maior deles. Você vai notar que há algumas verificações relacionadas à validade dos índices, uma vez que o índice deve estar dentro do intervalo $[0, tail]$.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">...
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">int</span> max_index(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index</span>, <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">left</span>, <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">right</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[index] <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[left]) {
            <span style="color:#66d9ef">if</span> (isValidIndex(right)) {
                <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[index] <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[right])
                    <span style="color:#66d9ef">return</span> right;
            }
           
            <span style="color:#66d9ef">return</span> index;
        
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> (isValidIndex(right)) {
                <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[left] <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[right])
                    <span style="color:#66d9ef">return</span> right;
            } 
            
            <span style="color:#66d9ef">return</span> left;
        }
    }

    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">boolean</span> isValidIndex(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index</span>) {
        <span style="color:#66d9ef">return</span> index <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">&lt;=</span> tail;
    }
    
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">boolean</span> isLeaf(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">index</span>) {
        returnn <span style="color:#a6e22e">index</span> <span style="color:#f92672">&gt;</span> parent(tail) <span style="color:#f92672">&amp;&amp;</span> index <span style="color:#f92672">&lt;=</span> tail;
    } 
    
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">void</span> swap(<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">i</span>, <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">j</span>) {
        <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">aux</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[i];
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[j];
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span>[j] <span style="color:#f92672">=</span> aux;
    }
...</code></pre></div>
<h3 id="eficiência-do-método-de-inserção-1">Eficiência do método de inserção</h3>

<p>No pior caso o heapify é executado até o nível das folhas. Nesse pior caso, o caminho percorrido é igual ao tamanho da altura, que sempre é $O(\log n)$ porque o Heap é completo ou quase-completo da esquerda para a direita.</p>

<blockquote>
<p>A remoção de um elemento no Heap é $O(\log n)$</p>
</blockquote>

<h2 id="build-heap">Build Heap</h2>

<p>Nem todo array representa um Heap, certo? Por exemplo, o array $a = [40, 87, 2, 90, 1, 100, 30, 20]$ não representa um Heap porque nem todo nó é maior do que os nós à esquerda e à direita, como ilustrado na figura abaixo.</p>

<p><img src="build-heap1.png" alt="build-heap1" /></p>

<p>O nosso desafio agora é transformar essa estrutura em um Heap. A ideia é aplicar sucessivas vezes o algoritmo <strong><em>heapify</em></strong>, discutido na seção anterior.</p>

<p>Nós começamos pelo pai da última folha. Por que? Porque a aplicação do heapify nas folhas é inútil, já que uma folha já respeita as propriedade de Heap.</p>

<p>Então, para o exemplo acima, vamos aplicar primeiro heapify no índice 3, que armazena o valor 90. Depois, vamos aplicar em todos os índices menores que 3 até a raiz, ou seja, heapify(2), heapify(1) e heapify(0). Ao final desse processo o array representará um Heap.</p>

<p>Vamos acompanhar passo a passo esse algoritmo. A primeira execução do heapify é no índice 3, que armazena 90. Como 90 é maior que o seu único filho, nada é feito. Depois aplicamos o heapify no índice 2, que armazena o valor 2. O heapify então compara 2, 100 e 30. Como 100 é maior, há a troca de valores entre 100 e 2. O resultado parcial até agora é o seguinte.</p>

<p><img src="build-heap2.png" alt="build-heap2" /></p>

<p>Agora falta aplicar no índice 1 e 0. Aplicando heapify no índice 1, o algoritmo compara 87 com 90 e 1. Como 90 é maior, há a troca de valores entre 90 e 87. Depois disso, 87 é comparado com 2. Como é maior, o algoritmo para. Até aqui, temos o seguinte cenário.</p>

<p><img src="build-heap3.png" alt="build-heap3" /></p>

<p>Por fim, falta apenas a última aplicação de heapify. Isso é feito no índice 0, ou seja, na raiz.O resultado final é ilustrado abaixo.</p>

<p><img src="build-heap4.png" alt="build-heap4" /></p>

<p>Em resumo, para construir um Heap a partir de um array qualquer basta aplicar <strong><em>heapify</em></strong> partindo do índice do pai da última folha até a raiz. O código abaixo implementa essa rotina.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">...
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Heap</span>(<span style="color:#66d9ef">int</span>[] <span style="color:#a6e22e">heap</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">heap</span> <span style="color:#f92672">=</span> heap;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">buildHeap</span>();
    }
    
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">void</span> buildHeap() {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> parent(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">tail</span>); i <span style="color:#f92672">&gt;=</span> 0; i<span style="color:#f92672">--</span>)
            heapify(i); 
    }
...</code></pre></div>
<hr />

<h1 id="notas">Notas</h1>

<p>O que facilita muito o aprendizado deste tipo de estrutura é utilizar uma ferramenta de visualização. Para fazer as figuras deste material eu utilizei <a class="external" href="http://btv.melezinek.cz/binary-heap.html">esta ferramenta.</a> Também acho o <a class="external" href="visualgo.net">VisualAlgo</a> uma excelente ferramenta para visualizar as estruturas que estudamos.</p>


</article>


<section class="post-nav">
    <ul>
        
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/bst/">Árvores Binárias de Pesquisa <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
    <h6><a href="http://joaoarthurbm.github.io">Copyright &copy; 2019 - João Arthur Brunet</a></h6>
    </footer>
</div>
<script src="https://joaoarthurbm.github.io/eda/js/scripts.js"></script>

</body>

</html>
