<!doctype html>

<html lang="en">

<head>
  <title>Estruturas de Dados e Algoritmos</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="João Arthur Brunet" /><meta name="generator" content="Hugo 0.59.0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />
  <script src="https://kit.fontawesome.com/b76b73e8e8.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://joaoarthurbm.github.io/eda/css/styles.css" /><script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151903059-1"></script>
<script>
      window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

            gtag('config', 'UA-151903059-1');
        </script>


</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://joaoarthurbm.github.io/eda/">Estruturas de Dados e Algoritmos</a>
            </h1>

      <ul id="social-media">
        
        
        
        <li><a href="https://twitter.com/joaobrunet"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="http://joaoarthurbm.github.io"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
           
        <li><a href="https://instagram.com/joaoarthurbm"><i class="fab fa-instagram fa-lg" aria-hidden="true"></i></a></li>
        
      </ul>
      
      <p><em>João Arthur Brunet <br> Computação @ UFCG</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/curso/">
                <i class="fa-li fa  fa-lg"></i><span>Curso</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/objetivos/">
                <i class="fa-li fa  fa-lg"></i><span>Objetivos</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/conteudo/">
                <i class="fa-li fa  fa-lg"></i><span>Conteúdo</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/contribua/">
                <i class="fa-li fa  fa-lg"></i><span>Contribua</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://joaoarthurbm.github.io/eda/bibliografia/">
                <i class="fa-li fa  fa-lg"></i><span>Bibliografia</span>
            </a>
        </li>
        
    </ul>
</nav>
    <main>




<article>

    <h1>Ordenação por Comparação: Insertion Sort</h1>    

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-10-27T01:01:01-03:00">Oct 27, 2019</time>
        </li>
        

        

        <li>7 minutes read</li>

        

        <aside><i class="fab fa-github fa-lg" aria-hidden="true"> </i> <a href="https://github.com/joaoarthurbm/eda-implementacoes/blob/master/java/src/sorting/Insertion.java"> <font color="#1980e6"> <b>Código utilizado neste material</b></font></a></aside>
        


    </ul>
</aside>

    

    

<hr />

<h1 id="direto-ao-ponto">Direto ao ponto</h1>

<p>O <em>Insertion Sort</em> tem como rotina base a inserção ordenada. A ideia é executar várias vezes essa rotina para ordenar um array. Para ser exato, se executarmos $N - 1$ vezes a rotina de inserção ordenada em um array o resultado é a ordenação completa do mesmo. Por isso, vamos antes entender como funciona inserção ordenada.</p>

<h1 id="inserção-ordenada">Inserção ordenada</h1>

<p>Vamos analisar o caso de um array com $N$ elementos no qual os $N - 1$ primeiros elementos estão ordenados, mas o último elemento não está no seu lugar. Isto é, precisamos encaixar o último elemento de forma que a sequência fique ordenada. No exemplo abaixo, estamos falando em inserir de forma ordenada o valor 12.</p>

<p align="center">values =[9, 13, 16, 21, 32, <font color="red">12</font>]</p>

<p>Como a sequência está ordenada até o penúltimo índice, a ideia é comparar 12 com o valor anterior e, se 12 for menor, trocar esses valores. Essas comparações e trocas só devem parar quando 12 for maior que o elemento à esquerda ou quando 12 estiver na primeira posição do array. Para visualizar o Insertion Sort, alguns autores utilizam a metáfora de uma mão de cartas. Nesse contexto, o objetivo seria encaixar a carta 12 na mão já ordenada. Veja o passo a passo:</p>

<p align="center">values = [9, 13, 16, 21, <font color="red">12</font>, 32]</p>
<p align="center">values = [9, 13, 16, <font color="red">12</font>, 21, 32]</p>
<p align="center">values = [9, 13, <font color="red">12</font>, 16, 21, 32]</p>
<p align="center">values = [9, <font color="red">12</font>, 13, 16, 21, 32]</p>

<p>O código que implementa essa rotina está descrito abaixo. O índice <code>j</code> assume o valor inicial <code>values.length - 1</code> (última posição) e a condição de parada do laço é satisfeita quando esse índice alcançar 0 ou quando o valor que queremos inserir de forma ordenada já está na sua posição (<code>values[j] &gt;= values[j-1]</code>). Se <code>j</code> alcançar 0, todo o array foi avaliado e o algoritmo deve parar. Da mesma forma, se <code>values[j] &gt;= values[j-1]</code> o algoritmo deve parar porque o elemento que estamos querendo encaixar já está em seu lugar.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">...
	<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">=</span> values.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;

	<span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> values[j] <span style="color:#f92672">&lt;</span> values[j<span style="color:#f92672">-</span>1]) {
            <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">aux</span> <span style="color:#f92672">=</span> values[j];
            values[j] <span style="color:#f92672">=</span> values[j<span style="color:#f92672">-</span>1];
            values[j<span style="color:#f92672">-</span>1] <span style="color:#f92672">=</span> aux;
            j <span style="color:#f92672">-=</span> 1;
    }
...</code></pre></div>
<h1 id="insertion-sort">Insertion Sort</h1>

<p>A parte complexa desse algoritmo de ordenação nós já entendemos &ndash; a inserção ordenada.</p>

<blockquote>
<p>O Insertion Sort aplica várias vezes a inserção ordenada para ordenar uma sequência.</p>
</blockquote>

<p>Vamos ver como isso é feito.</p>

<p>Queremos ordenar $values = [7, 1, 2, 3, 9, 5, 1]$. Se pensarmos bem, podemos ver os dois primeiros elementos desse array como sendo o cenário apresentado na seção anterior, isto é, temos que $[7, 1]$ está ordenado, exceto pela última posição. Se aplicarmos inserção ordenada em $[7, 1]$, temos como resultado $[1, 7]$.</p>

<p>Agora, vamos adotar a mesma postura com os três primeiros elementos: $[1, 7, 2]$. Novamente, podemos ver os 3 primeiros elementos como sendo o cenário para a inserção ordenada. Isto é $[1, 7, 2]$ está ordenado, exceto pelo último elemento. Se aplicarmos inserção ordenada em $[1, 7, 2]$, temos como resultado $[1, 2, 7]$.</p>

<p>Depois, vamos adotar a mesma postura com os quatro primeiros elementos: $[1, 2, 7, 3]$. Isto é, está ordenado, exceto pelo último elemento. Então basta aplicarmos inserção ordenada de 3. O resultado é $[1, 2, 3, 7]$.</p>

<p>Esse processo segue até o array ficar ordenado. Você percebeu que aplicamos inserção ordenada partindo do segundo elemento do array até o final? Isso significa que basta colocarmos um <strong><em>loop</em></strong> externo ao código de inserção ordenada, fazendo <code>j</code> variar de 1 até o último elemento. Vamos ao código:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">...
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertionSort</span>(<span style="color:#66d9ef">int</span>[] <span style="color:#a6e22e">values</span>) {
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;</span> values.<span style="color:#a6e22e">length</span>; i<span style="color:#f92672">++</span>) { 
		
		<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">=</span> i;
	
		<span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> values[j] <span style="color:#f92672">&lt;</span> values[j<span style="color:#f92672">-</span>1]) {
			<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">aux</span> <span style="color:#f92672">=</span> values[j];
			values[j] <span style="color:#f92672">=</span> values[j <span style="color:#f92672">-</span> 1];
			values[j <span style="color:#f92672">-</span> 1] <span style="color:#f92672">=</span> aux;
			j <span style="color:#f92672">-=</span> 1;
		}
	
	}	
}
...</code></pre></div>
<p>A única mudança que fizemos foi adicionar o comando <strong><em>for</em></strong> com <code>i</code> variando de 1 até o final e <code>j</code> variando de acordo com <code>i</code>.</p>

<p>Para fixar bem, veja a animação abaixo copiada <a class="external" href="https://medium.com/yay-its-erica/algorithms-for-beginners-bubble-sort-insertion-sort-merge-sort-29bd5506cc48"> deste material.</a> Note que a ideia é sempre inserir um elemento em uma sequência já ordenada.</p>

<figure style="align: center; margin-left:20%; width: 60%">
    <img src="animacao.gif">
</figure>

<h2 id="propriedades-e-análise-de-eficiência">Propriedades e Análise de eficiência</h2>

<blockquote>
<p>O Insertion Sort é estável, in-place e $O(n^2)$.</p>
</blockquote>

<p>Estabilidade é uma propriedade relacionada à ordem relativa de valores iguais no array original. Por exemplo, se houver dois valores 97 no array antes da ordenação, após a execução do algoritmo, esses dois valores devem seguir a ordem relativa inicial. Ou seja, ao término da execução do algoritmo, a primeira ocorrência do 97 deve vir antes da segunda ocorrência do 97.</p>

<p>O Insertion Sort é estável porque mantém a ordem relativa dos valores iguais. Isso ocorre porque as trocas são feitas sempre com vizinhos. Os valores vão sendo &ldquo;afastados&rdquo; um a um, e não dando saltos. Por isso, um elemento qualquer nunca trocará de posição com elementos de mesmo valor.</p>

<p>O Insertion Sort é <em>in-place</em> porque a ordenação é feita rearranjando os elementos no próprio array, ao invés de usar arrays ou outras estruturas auxiliares.</p>

<p>O pior caso do Insertion Sort é um array ordenado em ordem reversa, pois toda tentativa de inserção ordenada deve percorrer o array todo à esquerda trocando os elementos até encaixar o atual na primeira posição. Veja o exemplo:</p>

<p>Inserção ordenada de 20:
<p align="center">values = [90, <font color="red">20</font>, 16, 5, 1]</p>
<p align="center">values = [<font color="red">20</font>, 90, 16, 5, 1]</p></p>

<p>Inserção ordenada de 16:</p>

<p align="center">values = [20, 90, <font color="red">16</font>, 5, 1]</p>
<p align="center">values = [20, <font color="red">16</font>, 90, 5, 1]</p>
<p align="center">values = [<font color="red">16</font>, 20, 90, 5, 1]</p>

<p>Inserção ordenada de 5:
<p align="center">values = [16, 20, 90, <font color="red">5</font>, 1]</p>
<p align="center">values = [16, 20, <font color="red">5</font>, 90, 1]</p>
<p align="center">values = [16, <font color="red">5</font>, 20, 90, 1]</p>
<p align="center">values = [<font color="red">5</font>, 15, 20, 90, 1]</p></p>

<p>Inserção ordenada de 1:</p>

<p align="center">values = [5, 15, 20, 90, <font color="red">1</font>]</p>
<p align="center">values = [5, 15, 20, <font color="red">1</font>, 90]</p>
<p align="center">values = [5, 15, <font color="red">1</font>, 20, 90]</p>
<p align="center">values = [5, <font color="red">1</font>, 15, 20, 90]</p>
<p align="center">values = [<font color="red">1</font>, 5, 15, 20, 90]</p>

<p>Feito. Array ordenado.</p>

<p>Note que o tempo de execução é dado pela soma dos passos de cada iteração. Essa soma pode ser representada por $1 + 2 + 3 + &hellip; (n - 1)$, ou seja, uma Progressão Aritmética Finita (PA) com $a_1 = 1$ e $a_n = (n - 1)$ e razão $r=1$. A soma dos termos de uma PA é dada por: $(a_1+a_n)*n/2$. Então, temos que o tempo de execução do algoritmo é dado por $(1 + (n - 1)) * n/2 = (n^2)/2$. Aplicando as diretrizes de simplificação, o Insertion Sort é $\Theta(n^2)$.</p>

<p>No melhor caso, este algoritmo é $O(n)$. Isto ocorre quando o array já está ordenado. Deste maneira, a inserção ordenada de cada elemento tem custo $O(1)$, pois todos já estão em suas devidas posições. Como a inserção ordenada é executada $n$ vezes, o custo total é $O(n)$</p>

<p>É importante destacar que o Insertion Sort não é considerado um algoritmo eficiente para grandes entradas. Há alternativas $O(n*\log n)$, como Quick Sort e Merge Sort, além de alternativas lineares como o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/">Counting Sort</a>.</p>

<p>É também importante traçar o paralelo entre o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/selection-sort/">Selection Sort</a> e o Insertion Sort. O Selection efetua menos trocas do que o Insertion, pois há uma troca apenas por iteração, ou seja, no total o Selection Sort efetua $n$ trocas. Já o insertion sort efetua ao menos uma troca por iteração, pois deve efetuar trocas para afastar cada elemento avaliado.</p>

<p>Por outro lado, o Insertion Sort efetua menos comparações do que o Selection Sort, pois nem sempre o elemento a ser inserido de forma ordenada deve ir até o final. Na verdade, isso só acontece no pior dos casos, em que o array está ordenado em ordem reversa. Já o Selection Sort precisa comparar todos os elementos restante cada vez para determinar quem é o menor deles.</p>

<p>Na teoria, ambos estão na mesma classe de complexidade, qual seja $O(n^2)$. Na prática, o Insertion Sort apresenta melhor desempenho do que o Selection Sort.</p>

<hr />

<h1 id="resumo">Resumo</h1>

<ul>
<li><p>O Insertion Sort nada mais é do que a execução do algoritmo de inserção ordenada repetidas vezes.</p></li>

<li><p>O Insertion Sort é in-place, estável e $O(n^2)$.</p></li>

<li><p>O pior caso da execução deste algoritmo manifesta-se quando a entrada está ordenada em ordem decrescente.</p>

<ul>
<li>No melhor caso o Insertion Sort é $O(n)$. Isso ocorre quando o array já está ordenado.</li>
</ul></li>

<li><p>Na teoria, Insertion Sort, <a class="external" href="https://joaoarthurbm.github.io/eda/posts/selection-sort/">Selection Sort</a>  e Bubble Sort estão na mesma classe de complexidade, qual seja $O(n^2)$. Na prática, o Insertion Sort apresenta o melhor desempenho entre esses 3 algoritmos.</p></li>
</ul>

<hr />

<h1 id="notas">Notas</h1>

<p>Vale a pena utilizar o <a class="external" href="https://visualgo.net/en/sorting">VisuAlgo</a> para visualizar a execução do Selection Sort e de outros algoritmos de ordenação.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/merge-sort/"><i class="fa fa-chevron-circle-left"></i> Ordenação por Comparação: Merge Sort</a>
        </li>
        
        
        <li>
            <a href="https://joaoarthurbm.github.io/eda/posts/selection-sort/">Ordenação por Comparação: Selection Sort <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
    <h6><a href="http://joaoarthurbm.github.io">Copyright &copy; 2019 - João Arthur Brunet</a></h6>
    </footer>
</div>
<script src="https://joaoarthurbm.github.io/eda/js/scripts.js"></script>

</body>

</html>

