
   <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
     <channel>
       <title>Posts on Estrutura de Dados</title>
       <link>https://joaoarthurbm.github.io/eda/posts/</link>
       <description>Recent content in Posts on Estrutura de Dados</description>
       <generator>Hugo -- gohugo.io</generator>
       <copyright>Copyright &amp;copy; 2019 - João Arthur Brunet</copyright>
       <lastBuildDate>Wed, 30 Oct 2019 00:00:00 -0300</lastBuildDate>
       
           <atom:link href="https://joaoarthurbm.github.io/eda/posts/index.xml" rel="self" type="application/rss+xml" />
       
       
       <item>
         <title>Introdução à Análise de Algoritmos</title>
         <link>https://joaoarthurbm.github.io/eda/posts/introducao-a-analise/</link>
         <pubDate>Wed, 30 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/introducao-a-analise/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;A análise de eficiência é uma etapa fundamental na concepção de um algoritmo. Embora aspectos como legibilidade, simplicidade e modularidade de uma solução sejam importantes para a sua manutenabilidade, a eficiência de uma solução desempenha um papel muito relevante para a sua adoção.&lt;/p&gt;

&lt;p&gt;Diante de um problema computacional, diversas soluções podem ser propostas. Por exemplo, para ordenar um sequência de números, o desenvolvedor pode utilizar algoritmos como o BubbleSort, MergeSort, QuickSort entre outros. Entender como esses algoritmos se comportam à medida que aumentamos o tamanho da entrada a ser ordenada é primordial para decidirmos qual solução adotar em um determinado contexto.&lt;/p&gt;

&lt;p&gt;Analisar um algoritmo significa prever a quantidade de recursos que tal algoritmo consome ao ser executado. A análise pode apontar diversos candidatos e, tipicamente, exclui diversas soluções não eficientes. Diversas variáveis podem ser objetos de estudo da análise de um algoritmo, por exemplo, consumo de memória, largura de banda de comunicação entre outros. No entanto, com frequência, desejamos medir o tempo execução. E é essa variável que estamos interessados em discutir neste documento.&lt;/p&gt;

&lt;p&gt;Uma abordagem direta para analisar o desempenho de um algoritmo é a abordagem empírica. Neste caso, configura-se um ambiente em que as variáveis são controladas e executa-se os algoritmos com o intuito de medir o tempo de computação e comparar as diferentes soluções.
O tempo de execução (eixo y) é medido em função do tamanho da entrada (eixo x). Por exemplo, para analisar empiricamente um algoritmo de ordenação medimos o tempo de execução para diferentes tamanhos de arrays. Além disso, podemos querer variar a configuração do array sob ordenação para entender, por exemplo, como o algoritmo se comporta com um array já ordenado ou como se comporta com arrays parcialmente ordenados.&lt;/p&gt;

&lt;p&gt;Tipicamente, executa-se um experimento com o tamanho da amostra suficiente para se ter validade estatística e permitir a construção de um modelo que represente a curva de cada algoritmo. A Figura abaixo apresenta os tempos de computação de diferentes algoritmos de ordenação à medida que aumenta-se o tamanho da entrada. Como podemos notar, o algoritmo SelectionSort apresenta tempo de execução consideravelmente maior em comparação com as outras três alternativas à medida que a quantidade de elementos a serem ordenados cresce.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;comparacao-ordenacao.jpeg&#34; alt=&#34;comp-ordenacao&#34; title=&#34;Comparação de Algoritmos de Ordenação&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A abordagem empírica para análise de algoritmos é útil, pois, se conduzida de maneira metodologicamente apropriada, fornece valores precisos sobre o tempo de execução de um algoritmo. No entanto, essa abordagem apresenta algumas desvantagens. Primeiro, existe um alto custo relacionado à implementação de todos os algoritmos, além da configuração, execução e análise do experimento. Além disso, note que as conclusões são limitadas ao espaço de entrada do experimento. Por fim, os resultados são dependentes do hardware utilizado.&lt;/p&gt;

&lt;p&gt;Diante do cenário exposto acima, surge a necessidade de uma análise que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;seja independente de hardware;&lt;/li&gt;
&lt;li&gt;permita analisar os algoritmos em um espectro maior de entradas;&lt;/li&gt;
&lt;li&gt;seja simples.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note que, em diversas situações, o interesse está em comparar algoritmos, ao invés de determinar o seu tempo exato de execução. Em particular, &lt;strong&gt;estamos interessados nas funções no comportamento dos algoritmos para grandes tamanhos de entrada &amp;ndash; análise assintótica.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;análise-de-algoritmos&#34;&gt;Análise de Algoritmos&lt;/h2&gt;

&lt;p&gt;Antes de apresentar os conceitos de análise assintótica, sua notação e modus operandi, é preciso apresentar a hipótese em que a análise de algoritmos se baseia:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;Hipótese: O custo de operações primitivas é constante.&lt;/p&gt;

&lt;p&gt;Essa hipótese estabelece que operações aritméticas, indexação de elementos em um vetor, retorno de métodos, atribuição de valores às variáveis, comparação de elementos, entre outros, executam em tempo constante, referenciado como $O(1)$ ou $O(C)$. É importante destacar que, na prática, esse custo varia de acordo com o hardware, linguagem de programação etc. No entanto, essa variação é insignificante do ponto de vista da análise assintótica. O quadro abaixo lista as operações primitivas detalhadamente.&lt;/p&gt;

&lt;pre&gt;
Operações Primitivas

* Avaliação de expressões booleanas (i &gt;= 2; i == 2, etc);

* Operações matemáticas (*, -, +, %, etc);

* Retorno de métodos (return x;);

* Atribuição (i = 2);

* Acesso à variáveis e posições arbitrárias de um array (v[i]).

&lt;/pre&gt;

&lt;p&gt;Nesse contexto, o tempo de execução de um algoritmo é a soma do custo das operações primitivas. Por exemplo, considere o algoritmo que multiplica o resto da divisão de dois inteiros pela parte inteira da mesma divisão:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;multiplicaRestoPorParteInteira&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resto&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; j;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pInteira&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; j;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resultado&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; resto &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pInteira;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; resultado;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1: Identificar primitivas.&lt;/strong&gt; O primeiro passo para determinar de modo analítico o tempo de execução de qualquer algoritmo é identificar todas as operações primitivas. Cada uma, como discutido anteriormente, tem um custo constante. Para o algoritmo acima temos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;atribuição (resto = ) -&amp;gt; $c1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (i % j) -&amp;gt; $c2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (pInteira = ) -&amp;gt; $c3$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (i % j) -&amp;gt; $c4$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (resultado = ) -&amp;gt; $c5$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (resto * pInteira) -&amp;gt; $c6$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;retorno de método (return resultado) -&amp;gt; $c7$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt; Para o algoritmo acima, todas as primitivas são executadas apenas uma vez.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt; O tempo de execução do algoritmo é a soma das execuções das operações primitivas. Nesse caso temos que a função que descreve o tempo de execução é:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = c1+c2+c3+c4+c5+c6+c7$&lt;/p&gt;

&lt;p&gt;Lembrando estamos interessados em uma função que nos diga o tempo de execução em relação ao tamanho da entrada. Nesse caso, escolhemos $n$ para representar o tamanho da entrada. Como pode ser visto na função detalhada, o custo não depende de $n$ de maneira alguma. Independente dos números passados como parâmetro, o custo será sempre o mesmo. Por isso dizemos que essa função, e portanto o algoritmo que é descrito por ela, tem &lt;strong&gt;custo constante&lt;/strong&gt;, ou seja, independe do tamanho da entrada.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dizer que um algoritmo tem custo constante significa dizer que o seu tempo de execução independe do tamanho da entrada.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Outro fator de destaque é que podemos considerar que todas as constantes possuem o mesmo valor $c$. Assim, podemos simplificar a função para $f(n)= 7c$.&lt;/p&gt;

&lt;h3 id=&#34;e-quando-houver-condicionais&#34;&gt;E quando houver condicionais?&lt;/h3&gt;

&lt;p&gt;O uso de comandos condicionais é muito comum em nossos algoritmos e nos impõe uma dificuldade na análise do tempo de execução. Essa dificuldade está relacionada ao fato de que, dependendo do caso, apenas uma parte do código é executada. Como decidir como fazer a análise? Que caminho devemos computar?&lt;/p&gt;

&lt;p&gt;Nesse caso, escolhemos &lt;strong&gt;o pior caso&lt;/strong&gt;. Neste curso estamos interessados em saber como os algoritmos se comportam no seu pior caso. A análise do pior caso é útil para eliminarmos soluções ruins. Além disso, o melhor caso raramente acontece, ao contrário dos outros casos que podem ser bem mais comuns. Por último, o caso médio, além de demandar análise estatística, muitas vezes é muito semelhante ao pior caso.&lt;/p&gt;

&lt;p&gt;Para demonstrar a análise de pior caso, vamos analisar um método que recebe as três notas de um aluno e calcula a nota que ele precisa obter na prova final, se esse for o caso. Se o aluno for aprovado ($media &amp;gt;= 7.0$) ou reprovado sem direito a final ($media &amp;lt; 4$), o método deve retornar $0$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;precisaNaFinal&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nota1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nota2&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nota3&lt;/span&gt;) {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;media&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (nota1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nota2 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nota3) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 3;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (media &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 7 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; media &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 4) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 0;
        
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mediaFinal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 5;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pesoFinal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0.&lt;span style=&#34;color:#a6e22e&#34;&gt;4&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pesoMedia&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0.&lt;span style=&#34;color:#a6e22e&#34;&gt;6&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;precisa&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (mediaFinal &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; pesoMedia &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; media) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; pesoFinal;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; precisa;
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1. Identificar primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;atribuição (media = ) -&amp;gt; $c1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (nota1 + nota2 + nota3) -&amp;gt; $c2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (&amp;hellip; / 3) -&amp;gt; $c3$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;avaliação de expressão booleana (media &amp;gt;=7 || media &amp;lt; 4) -&amp;gt; $c4$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;retorno de método (return 0) -&amp;gt; $c5$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (mediaFinal = ) -&amp;gt; $c6$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (pesoFinal = ) -&amp;gt; $c7$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (pesoMedia = ) -&amp;gt; $c8$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (precisa = ) -&amp;gt; $c9$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (pesoMedia * media) -&amp;gt; $c10$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (mediaFinal -  &amp;hellip;) -&amp;gt; $c11$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (&amp;hellip; / pesoFinal) -&amp;gt; $c12$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;retorno de método (return precisa) -&amp;gt; $c13$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt; Aqui vem a grande diferença. Como estamos interessados no pior caso, nós vamos descartar a constante $c5$, pois, no pior caso, o bloco do &lt;code&gt;else&lt;/code&gt; será executado, uma vez que é mais custoso que o bloco do &lt;code&gt;if&lt;/code&gt;. As outras primitivas são executadas apenas uma vez.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = c1+c2+c3+c4+c6+c7+c8+c9+c10+c11+c12+c13$ &lt;/p&gt;

&lt;h3 id=&#34;e-quando-houver-iteração&#34;&gt;E quando houver iteração?&lt;/h3&gt;

&lt;p&gt;Nos dois exemplos que vimos até aqui todas as primitivas são executadas apenas uma vez e, por isso, o tempo de execução do algoritmo é sempre constante. Vejamos o que acontece quando há iteração. O código abaixo procura por um elemento em um array.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;contains&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (v[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1: Identificar primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Atribuição (int i = 0) -&amp;gt; $c1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (i &amp;lt; v.length) -&amp;gt; $c2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operação aritmética (i++) -&amp;gt; $c3$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (v[i] == n) -&amp;gt; $c4$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return true) -&amp;gt; $c5$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return false) -&amp;gt; $c6$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Aqui mora a grande diferença da análise deste exemplo em relação aos demais. Em primeiro lugar, nem todas as primitivas são executadas apenas uma vez. Depois, temos que voltar a lembrar que estamos tratando do pior caso. Esse cenário é representado por um array que não contém o número procurado, pois o algoritmo irá realizar todas as iterações e retornar &lt;code&gt;false&lt;/code&gt; no final. Veja que se o número procurado estiver presente, a execução pode terminar bem antes do fim da iteração no array. Isso significa que na nossa análise vamos descartar a primitiva $c5$, pois no pior caso ela nunca é executada.&lt;/p&gt;

&lt;p&gt;Dado que o tamanho do vetor (&lt;code&gt;v.length&lt;/code&gt;) é $n$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$c1$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c2$ é executada $(n+1)$ vezes. Exemplo: se $n = 5$, temos as seguintes verificações: 0 &amp;lt; 5, 1 &amp;lt; 5; 2 &amp;lt; 5, 3 &amp;lt; 5, 4 &amp;lt; 5 e 5 &amp;lt; 5, quando encerra-se o loop. Ou seja, 6 verificações.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c3$ é executada $n$ vezes. Exemplo: se $n = 5$, temos os seguintes incrementos em i: 1, 2, 3, 4 e 5, quando encerra-se o loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c4$ é executada $n$ vezes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No pior caso, $c5$ não é executada.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c6$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O tempo de execução do algoritmo é a soma das execuções das operações primitivas. Nesse caso temos que a função que descreve o tempo de execução é:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = c1+c2*(n+1)+c3*n+c4*n+c6$ &lt;/p&gt;

&lt;p&gt;Considerando todas as primitivas com custo $c$ e simplificando a função, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = 3*c*n+3*c$ &lt;/p&gt;

&lt;p&gt;Veja que essa função é diretamente relacionada ao tamanho do array ($n$). À medida que cresce o tamanho de $n$, cresce também o tempo de execução do pior caso. Esse crescimento é linear, pois a função é linear. Faz sentido, certo? Iterar em um array com 100 posições é 10 vezes mais lento que iterar em um array de 10 posições. Não é por acaso que o nome desse algoritmo é busca linear. O termo refere-se a ambos: i) a estratégia de procurar o elemento de modo sequencial em uma coleção e ii) o tempo de execução do algoritmo.&lt;/p&gt;

&lt;p&gt;Vamos ver mais um exemplo.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; contemDuplicacao(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (v[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; v[j])
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1: Identificar primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Atribuição (int i = 0) -&amp;gt; c1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (i &amp;lt; v.length) -&amp;gt; c2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operação aritmética (i++) -&amp;gt; c3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Atribuição (int j = i + 1) -&amp;gt; c4&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (j &amp;lt; v.length) -&amp;gt; c5&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operação aritmética (j++) -&amp;gt; c6&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (v[i] == v[j]) -&amp;gt; c7&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return true) -&amp;gt; c8&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return false) -&amp;gt; c9&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O pior caso de execução desse algoritmo é quando não há repetição de valores no array. Ou seja, os loops são executados até o final. Então, como estamos falando do pior caso, descartamos $c8$, porque no pior caso essa primitiva nunca será executada.&lt;/p&gt;

&lt;p&gt;Dado que o tamanho do vetor (v.length) é $n$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$c1$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c2$ é executada $(n+1)$ vezes. Exemplo: se $n = 5$, temos as seguintes verificações: 0 &amp;lt; 5, 1 &amp;lt; 5; 2 &amp;lt; 5, 3 &amp;lt; 5, 4 &amp;lt; 5 e 5 &amp;lt; 5, quando encerra-se o loop. Ou seja, 6 verificações.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c3$ é executada $n$ vezes. Exemplo: se $n = 5$, temos os seguintes incrementos em i: 1, 2, 3, 4 e 5, quando encerra-se o loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Agora, atenção, porque vamos tratar das primitivas do laço mais interno.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A quantidade de vezes que $c4$ é executada depende do laço mais externo, pois $j$ varia de acordo com $i$ ($j = i+1$). Como o laço externo executa $n$ vezes, a quantidade de vezes que $j$ varia é dada por: $(n - 1) + (n - 2) + (n - 3) + (n-4) + &amp;hellip;1$. Essa série representa uma Progressão Aritmética finita decrescente com razão 1. A soma de uma PA com essas características é dada por $S = n/2 * (a1+an)$, onde $a1$ e $an$ são o primeiro e o último elemento da sequência, respectivamente. Assim, para $a1=1$ e $an = n-1$, temos que $c4$ é executada ${n^2}/{2}$ vezes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Como $c5$ é executada uma vez a mais que $c4$ por causa do último teste para sair do laço, então temos que o primeiro termo da PA é $a1 = 1$ e $an = n$. Assim, temos que $c5$ é executada $({n^2 + n})/{2}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c6$ e $c7$ são executadas a mesma quantidade de vezes que $c4$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c8$ não é executada nenhuma vez porque estamos falando do pior caso&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c9$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O tempo de execução do algoritmo é a soma das execuções das operações primitivas. Nesse caso temos que a função que descreve o tempo de execução é:&lt;/p&gt;

&lt;p&gt;$f(n) = c1 + c2*(n+1) + c3*n + c4 * {n^2}/2 + c5 * (n^2 + n)/2 + c6 * {n^2}/2 + c7 * {n^2}/2 + c9$&lt;/p&gt;

&lt;p&gt;Considerando todas as primitivas com custo c e simplificando a função, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = 3 * c + 2 * c * n + 3 * {n^2}/2 + c * (n^2 + n)/2$ &lt;/p&gt;

&lt;p&gt;Veja que essa função é diretamente relacionada ao tamanho do array (n). À medida que cresce o tamanho de $n$, cresce também o tempo de execução do pior caso. O tempo de execução do algoritmo cresce de forma quadrática em relação ao tamanho da entrada, pois a função é quadrática. Faz sentido, certo? Comparar cada elemento de um array com todos os outros é da ordem de $n^2$.&lt;/p&gt;

&lt;p&gt;É importante que você entenda que esse algoritmo é bem mais lento do que o anterior, pois uma função quadrática cresce mais rapidamente que uma função linear.&lt;/p&gt;

&lt;p&gt;No material sobre &lt;a href=&#34;http://joaoarthurbm.github.io/eda/posts/analise-assintotica&#34;&gt;Análise Assintótica&lt;/a&gt; vamos aprender que essa função complicada pode ser simplificada para $n^2$ quando tratamos de grandes entradas, pois as constantes e os expoentes de menor magnitude não impactam muito nesse cenário.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;resumo&#34;&gt;Resumo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Calcular o tempo de execução de um algoritmo é muito importante.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uma forma de calcular o tempo de execução é seguir os passos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identificar primitivas&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Identificar o número de vezes que cada uma das primitivas é executada&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Somar o custo total&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;É preciso estar atento para o fato de que estamos falando de análise do pior caso e, por isso, descartamos os fluxos alternativos de menor custo.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
       </item>
       
       <item>
         <title>Análise Assintótica</title>
         <link>https://joaoarthurbm.github.io/eda/posts/analise-assintotica/</link>
         <pubDate>Tue, 29 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/analise-assintotica/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;O Problema.&lt;/strong&gt; No &lt;a href=&#34;http://joaoarthurbm.github.io/eda/posts/introducao-a-analise/&#34;&gt;material introdutório de análise de algoritmos&lt;/a&gt; aprendemos a definir a função que descreve o custo de execução de algoritmos. Vimos exemplos simples cujas funções são também simples. Contudo, vamos supor que a função que descreve o tempo de execução de um algoritmo é dada por:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $1.1 * n^2 + (10 + \sin(n + 15) * n^{1.5}) + 9000$ &lt;/p&gt;

&lt;p&gt;Você há de convir que não é simples olhar para essa função e ter uma ideia clara do crescimento dela, certo? Lembra que nossa motivação para estabelecer essa função é simplificar nossa vida. É olhar para a função e ter uma ideia de como ela se comporta à medida que o tamanho da entrada cresce. Então, temos um problema aqui. Essa função não está ajudando nossa vida. Precisamos simplificá-la.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Solução.&lt;/strong&gt; Simplificar. Na verdade, nós já utilizamos algumas simplificações para facilitar a análise de algoritmos. A principal delas é ignorar o custo real das operações primitivas, utilizando a constante C ou 1. Agora, faremos mais uma abstração simplificadora, chamada &lt;strong&gt;ordem de crescimento&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A ideia é determinar como o algoritmo se comporta para valores muito grandes de entrada. Neste caso, ignoramos as constantes e os valores de menor magnitude por entender que eles não são significativos diante dos valores de maior magnitude.&lt;/p&gt;

&lt;p&gt;Na prática, isso significa dizer que podemos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ignorar as constantes;&lt;/li&gt;
&lt;li&gt;ignorar os expoentes de menor magnitude.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No exemplo fictício da função acima, podemos então fazer as seguintes simplificações.&lt;/p&gt;

&lt;p&gt;f(n) = &lt;del&gt;1.1&lt;/del&gt; * n ** 2 &lt;del&gt;+ (10 + sin(n+15)*n**1.5) + 9000&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;Ou seja, do ponto de vista da ordem de crescimento, para grandes valores de $n$, as constantes e os expoentes de maior magnitude são insignificantes, nos permitindo simplificar a expressão do tempo de execução para $\Theta(n^2)$. A notação theta será discutida com mais detalhes na próxima seção.&lt;/p&gt;

&lt;p&gt;Agora sim, é muito mais direto olhar para $n^2$ ter uma ideia clara do crescimento do tempo de execução do algoritmo, porque $n^2$ é uma função que já conhecemos bastante.&lt;/p&gt;

&lt;p&gt;O interesse está na ordem de crescimento das funções, que facilita a análise e comparação de diferentes soluções. Por exemplo, na escolha entre uma solução $\Theta(\log n)$ e uma solução $\Theta(n)$, é preferível a primeira, pois à medida que o tamanho da entrada cresce, o tempo de execução cresce mais lentamente que $\Theta(n)$.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Ainda não entendi. Você está querendo dizer que $f(n) = 1.1 * n^2 + (10 + \sin(n + 15) * n^{1.5}) + 9000$ e $g(n) = n^2$ são iguais?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Não. Eu estou dizendo que elas pertencem à mesma classe de funções, as funções quadráticas. Eu estou querendo dizer que essas duas funções possuem a mesma ordem de crescimento para grandes entradas e que se aproximam muito uma da outra para grandes valores de $n$.&lt;/p&gt;

&lt;p&gt;Vou te mostrar. Os gráficos da sequência abaixo ilustra essas duas funções. $f(n)$ está destacada em azul e $g(n)$ em vermelho. A única diferença é que a entrada (eixo x) vai aumentando de um gráfico para outro.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;passo1.png&#34; alt=&#34;passo1&#34; /&gt;
&lt;img src=&#34;passo2.png&#34; alt=&#34;passo2&#34; /&gt;
&lt;img src=&#34;passo3.png&#34; alt=&#34;passo3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que no primeiro gráfico, para entradas de 0 a 200, $f(x)$ tem uma curva semelhante à $g(x)$, mas estão distantes uma da outra. Depois, na segunda figura, a entrada passa a variar de 0 a 300 e já conseguimos notar uma aproximação dessas duas curvas. Por fim,  no último gráfico, com entradas variando de 0 a 400, as duas curvas já estão muito próximas uma da outra.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outro exemplo.&lt;/strong&gt; Através da identificação das operações primitivas e da quantidade de vezes que são executadas no algoritmo de busca linear chegamos à seguinte função:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = 3*c*n + 3*c$&lt;/p&gt;

&lt;p&gt;Aplicando as diretrizes simplificação, temos:&lt;/p&gt;

&lt;p&gt;f(n) = &lt;del&gt;3 * c *&lt;/del&gt; n &lt;del&gt;+ 3 * c&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;Isto é, $f(n) = 3*c*n+3*c$ é $\Theta(n)$. Isso significa dizer que f(n) tem a mesma ordem de crescimento que uma função linear.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dizer que um algoritmo é linear significa que o tempo de execução do algoritmo cresce linearmente em função do tamanho da entrada.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Mais um exemplo.&lt;/strong&gt; Através da identificação das operações primitivas e da quantidade de vezes que são executadas no algoritmo de identificação de elementos duplicados em um array chegamos à seguinte função:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = 3 * c + 2 * c * n + 3 * {n^2}/2 + c * (n^2 + n)/2$ &lt;/p&gt;

&lt;p&gt;Aplicando as diretrizes simplificação, temos que $f(n) = \Theta(n^2)$. Isso significa dizer que $f(n)$ tem a mesma ordem de crescimento que uma quadrática.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;análise-assintótica&#34;&gt;Análise Assintótica&lt;/h1&gt;

&lt;p&gt;Quando observamos tamanhos de entrada grande o suficiente para tornar relevante apenas a ordem de crescimento do tempo de execução, estamos estudando a eficiência assintótica.&lt;/p&gt;

&lt;p&gt;Há pouco, aplicando as diretrizes de simplificação, aprendemos que funções complexas podem ser mapeadas para classes de funções sobre as quais conhecemos o crescimento ($n$, $\log n$, $n^2$ etc). Para ilustrar esse mapeamento utilizamos a notação $\Theta$. Chegou a hora de entendermos o que essa notação significa.&lt;/p&gt;

&lt;p&gt;Primeiro, preciso deixar claro que cometi alguns abusos matemáticos para fins didáticos. Vamos relembrar esses abusos e explicá-los um a um.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$2*n + 1 = \Theta(n)$&lt;/p&gt;

&lt;p&gt;Theta ($\Theta$) é um conjunto de funções. Nesse caso, o conjunto das funções lineares. Por isso, é um abuso dizer que $2*n + 1$ &lt;strong&gt;é&lt;/strong&gt; $\Theta(n)$. A maneira formal de dizer é: $2*n + 1$ &lt;strong&gt;pertence&lt;/strong&gt; à $\Theta(n)$.&lt;/p&gt;

&lt;p&gt;Além disso, poderíamos ter escolhido qualquer função linear para dizer que $2 * n + 1$ tem a mesma ordem de crescimento. Nós escolhemos $n$ porque é a mais simples.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-notação-theta&#34;&gt;A notação $\Theta$&lt;/h1&gt;

&lt;p&gt;Agora vamos definir formalmente o que significa essa notação. Para duas funções $f(n)$ e $g(n)$, dizemos que $f(n)$ é $\Theta(g(n))$ se&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=c1*g(n)&lt;= f(n)&lt;= c2*g(n), \forall n&gt;=n0$&lt;/p&gt;

&lt;p&gt;Vamos entender o que essa inequação complicada quer nos dizer. Em um resumo bem simplista ela está dizendo que se a gente &amp;ldquo;imprensar&amp;rdquo; $f(n)$ com $g(n)$ multiplicada por duas constantes diferentes, dizemos que $f(n)$ é $\Theta(g(n))$.&lt;/p&gt;

&lt;p&gt;Vamos ao exemplo. Lembra da função que descreve o tempo de execução da busca linear? Vamos tentar demonstrar que essa função é $\Theta(n)$.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = 3*c*n+3*c$&lt;/p&gt;

&lt;p&gt;O primeiro passo que vamos fazer é trocar as constantes por 1. Isso já foi dito antes. Usar $c$ ou 1 tem o mesmo efeito. Assim, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = 3n+3$&lt;/p&gt; 

&lt;p&gt;Agora vamos voltar a inequação. Como &amp;ldquo;desconfiamos&amp;rdquo; que $f(n) = 3n+3$ é $\Theta(n)$, escolhemos $g(n)=n$. Poderíamos escolher qualquer função linear para representar $g(n)$, escolhemos a função linear mais simples para facilitar nossa vida. Assim, a inequação fica:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=c1*n&lt;= 3n+3&lt;= c2*n, \forall n&gt;=n0$&lt;/p&gt;  

&lt;p&gt;Agora precisamos encontrar valores para $c1$ e $c2$ para que essa inequação seja verdadeira. Vamos tentar com c1=1 e c2=6.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=n&lt;= 3n+3&lt;= 6*n, \forall n&gt;=n0$&lt;/p&gt;  

&lt;p&gt;Se verificarmos com $n=1$, vemos que a inequação é verdadeira:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=1&lt;= 6&lt;= 6$&lt;/p&gt;  

&lt;p&gt;Não é difícil também notar que $\forall n &amp;gt; 1$ ela sempre será verdadeira. Conseguimos, então, demonstrar que $f(n) \in \Theta(n)$, pois $g(n)=n$ limita inferior e superiomente $f(n)$.&lt;/p&gt;

&lt;p&gt;Na verdade, todas as funções lineares são limitadas inferior e superiormente por $n$. No nosso linguajar, podemos dizer que todas as funções abaixo pertencem à $\Theta(n)$.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$7*n, 827643*n, 5n+21, 54n +1...$&lt;/p&gt;  

&lt;p&gt;Formalmente dizemos que $g(n)=n$ é um limite assintótico restrito para $f(n)$. A figura abaixo descreve essa relação entre uma função quadrática e as funções $3n$ e $n^2$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;theta.png&#34; alt=&#34;theta&#34; width=&#34;1px&#34; height=&#34;320px&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Em português estamos dizendo que existe, para grandes valores de $n$ e a partir de um número inteiro positivo $n0$, $c1$ e $c2$ tais que $c1*g(n)&amp;lt;= f(n)&amp;lt;= c2*g(n)$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Em termos simplistas, $f(n) \in \Theta(g(n))$ significa dizer que o crescimento de f(n) é igual ao de g(n).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Outro exemplo.&lt;/strong&gt; Suponha que a função $7 * n^4 + 5 * n^2 +10$ descreva o custo de execução de um algoritmo. Se aplicarmos as abstrações simplificadoras, desconfiamos que $f(n) \in \Theta(n4)$, certo? Vamos demonstrar formalmente.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0 &lt;= c1 * n^4 &lt;= 7 * n^4 + 5 * n^2 + 10 &lt;= c2*n4, \forall n &gt;= n0$&lt;/p&gt;  

&lt;p&gt;Se escolhermos $c1=7$, $c2=22$ e $n0=1$, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 0 &lt;=7 &lt;= 22 &lt;= 22 $&lt;/p&gt;

&lt;p&gt;Na verdade, todas as funções quadráticas são limitadas inferior e superiormente por $n^2$. No nosso linguajar, podemos dizer que todas as funções abaixo pertencem à $\Theta(n^2)$.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 43 * n^2 + 7n + 1, 5 * n^2 + 21, 7 * n^2...$ &lt;/p&gt;

&lt;p&gt;Em resumo, para demonstrar formalmente precisamos dos seguintes passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Aplicar as abstrações simplificadores em $f(n)$ para termos uma proposta para $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Encontrar valores de $c1$, $c2$ e $n0$ para os quais a inequação $0&amp;lt;=c1*g(n)&amp;lt;= f(n)&amp;lt;= c2*g(n)$ é verdadeira.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Há mais 4(!) notações para estabelecer a relação entre funções. Neste material vamos ver apenas mais duas porque considero que é suficiente. Independente disso, todas são nada mais do que alterações na inequação que estabelecemos para $\Theta$. Por exemplo, a próxima notação que veremos, provavelmente a mais popular de todas, nada mais é do que retirar o limite inferior da inequação e apenas estabelecer um limite superior.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notação-o-big-o-notation&#34;&gt;Notação O (Big O notation)&lt;/h1&gt;

&lt;p&gt;Enquanto a notação $\Theta$ define os limites inferior e superior de uma função, a notação $O$ define apenas o limite superior. Ou seja, define um teto para uma determinada função.&lt;/p&gt;

&lt;p&gt;Para duas funções $f(n)$ e $g(n)$, dizemos que $f(n)$ é $O(g(n))$ se:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0&lt;=f(n)&lt;= c*g(n), \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Veja que a diferença entre essa inequação e a utilizada para a notação é o fato de que aqui o limite inferior é 0 e não $c1 * g(n)$. A figura abaixo ilustra essa relação.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bigo.png&#34; alt=&#34;bigo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O processo para demonstrar que $f(n)$ é $O(g(n))$ é muito semelhante, mas nesse caso precisamos achar apenas os valores de $c$ e $n0$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exemplo.&lt;/strong&gt; Suponha que a função $n^2 + 1$ descreva o custo de execução de um algoritmo. Se aplicarmos as abstrações simplificadoras, desconfiamos que $f(n) \in O(n^2)$, certo? Vamos demonstrar formalmente.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0 &lt;= n^2 + 1 &lt;= c * n^2, \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Se escolhermos c1=1 e n0=1, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $1 &lt;= 1$ &lt;/p&gt;

&lt;p&gt;Como você pode perceber, toda função que pertence à $\Theta(n^2)$ também pertence à $O(n^2)$, porque $\Theta$ limita também superiormente como $O$. No entanto, nem toda função que pertence à $O(n^2)$, por exemplo, também pertence à $\Theta(n)$, pois $O$ estabelece apenas o limite superior. Por exemplo, a função $f(n) = 7$ é limitada superiormente por $n^2$ e, portanto, é $O(n^2)$. Todavia, não podemos dizer que ela é $\Theta(n^2)$ porque não há constante multiplicadora que, para n suficientemente grande, faça com que $c1 * n^2$ seja menor do que $7n$.&lt;/p&gt;

&lt;p&gt;Simples, não é? A notação $O$ é bastante utilizada em Computação para discutir a eficiência de algoritmos. E há aqui uma curiosidade. Como discutido no parágrafo anterior, basta escolhermos uma função com $n$ elevado a um expoente maior do que o da função sob análise que conseguimos definir um limite superior para ele. Por exemplo, a função $f(n) = n^2$ é $O(n^2)$, $O(n^3)$, $O(n^4)$, e assim por diante.  Todavia, faz mais sentido escolhermos uma função com o mesmo expoente, porque a informação é mais precisa. Ou seja, se uma função é quadrática, dizemos que ela é $O(n^2)$.&lt;/p&gt;

&lt;p&gt;Por fim, outra particularidade dessa notação é que usamos com muita frequência nas discussões do a dia a notação $O$ ao invés da notação $\Theta$. Talvez porque seja mais fácil de falar $O$ do que theta e, como somos preguiçosos, tendemos a economizar energia até na fala. Mas é relevante destacar que, tipicamente, a semântica que queremos empregar nas discussões com o uso da notação $O$ é a mesma de $\Theta$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Em termos simplistas, $f(n) \in O(g(n))$ significa dizer que o crescimento de f(n) é menor ou igual ao crescimento de g(n).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notação-omega-omega&#34;&gt;Notação Omega ($\Omega$)&lt;/h1&gt;

&lt;p&gt;A notação $\Theta$ define o limite inferior e superior. $O$ define apenas o limite superior. E $\Omega$? Acertou. Apenas o limite inferior. Para duas funções $f(n)$ e $g(n)$, dizemos que $f(n)$ é $\Omega(g(n))$ se:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 0 &lt;= c * g(n) &lt;= f(n), \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;A figura abaixo ilustra essa relação.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;omega.png&#34; alt=&#34;omega&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O processo para demonstrar que $f(n)$ é $\Omega(g(n))$ é muito semelhante, mas nesse caso precisamos achar apenas os valores de $c$ e $n0$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exemplo.&lt;/strong&gt; Suponha que a função $n^2 + 1$ descreva o custo de execução de um algoritmo. Se aplicarmos as abstrações simplificadoras, desconfiamos que $f(n) \in \Omega(n^2)$, certo? Vamos demonstrar formalmente.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 0 &lt;= c * n^2 &lt;= n^2 + 1, \forall n &gt;= n0$ &lt;/p&gt;

&lt;p&gt;Se escolhermos $c1=1$ e $n0=1$, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 1 &lt;= 2$ &lt;/p&gt;

&lt;p&gt;Não é difícil perceber que essa inequação é verdadeira para todo $n0$ maior do que 1.&lt;/p&gt;

&lt;p&gt;Como você pode perceber, toda função que pertence à $\Theta(n^2)$ também pertence à
$\Omega(n^2)$, porque $\Theta$ limita também inferiormente como $\Omega$. Contudo, nem toda função que pertence à $\Omega(n^2)$ também pertence à $\Theta(n^2)$, pois $\Omega(n^2)$ estabelece apenas o limite inferior. Por exemplo, a função $f(n) = 7 * n$ é limitada inferiormente por $n$, portanto é $\Omega(n)$. Contudo, não podemos dizer que ela é $\Theta(n^2)$ porque não há constante multiplicadora que para $n$ suficientemente grande faça com que $c1 * n$ seja maior do que $7 * n^2$.&lt;/p&gt;

&lt;p&gt;É simples definir um limite inferior para qualquer função. Basta utilizar o expoente 0. Ou seja, todas as funções são $\Omega(1)$. Mais do que isso, podemos escolher expoentes menores. Por exemplo, a função $f(n) = n^2$ é $\Omega(n)$, $\Omega(log n)$ e $\Omega(1)$. Todavia, faz mais sentido escolhermos uma função com o mesmo expoente, porque a informação é mais precisa. Ou seja, se uma função é quadrática, dizemos que ela é $\Omega(n^2)$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Em termos simplistas, $f(n) \in \Omega(g(n))$ significa dizer que o crescimento de
f(n) é maior ou igual ao crescimento de g(n).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As duas notações restantes são $o$ (o minúsculo) e $\omega$ (omega minúsculo). Como disse, eu considero essas duas notações menos importantes que as demais e não vou discuti-las de forma aprofundada.&lt;/p&gt;

&lt;p&gt;** Apenas deixo aqui registrado que $o$ é muito semelhante à $O$, removendo apenas o sinal de igualdade da inequação:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0&lt;=f(n)&lt; c*g(n), \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Ou seja, &lt;strong&gt;não&lt;/strong&gt; podemos dizer, por exemplo, que $f(n) = n^2 + 3$ é $o(n^2)$. $f(n) = n^2 + 3$ é $o(n^3)$, $o(n^4)$, $o(n^5)$ etc.&lt;/p&gt;

&lt;p&gt;Por outro lado, $\omega$ é muito semelhante à $\Omega$, removendo apenas o sinal de igualdade da inequação:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0 &lt;= c*g(n) &lt; f(n), n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Ou seja, &lt;strong&gt;não&lt;/strong&gt; podemos dizer, por exemplo, que $f(n) = n^3 + 2$ é $\omega(n^3)$. $f(n) = n^3 + 2$ é $\omega(n^2)$, $\omega(n)$, $\omega(log n)$ etc.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Este material foi inspirado nos Capítulos 3 e 4 do livro &amp;ldquo;Algoritmos: Teoria e Prática&amp;rdquo; de Cormen et. al.&lt;/p&gt;

&lt;p&gt;Para entender este material é muito importante ler a &lt;a href=&#34;http://joaoarthurbm.github.io/eda/posts/introducao-a-analise&#34;&gt;introdução à análise de algoritmos&lt;/a&gt;.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Análise de Algoritmos Recursivos</title>
         <link>https://joaoarthurbm.github.io/eda/posts/analise-algoritmos-recursivos/</link>
         <pubDate>Mon, 28 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/analise-algoritmos-recursivos/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Até aqui vimos como &lt;a href=&#34;http://joaoarthurbm.github.io/eda/posts/introducao-a-analise&#34;&gt;analisar algoritmos iterativos&lt;/a&gt;, lembra? Esse processo pode ser resumido pelos seguintes passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;identificar operações primitivas;&lt;/li&gt;
&lt;li&gt;identificar a quantidade de vezes que cada uma dessas primitivas é executada;&lt;/li&gt;
&lt;li&gt;Somar essas execuções.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;
Você lembra quais são as operações primitivas?
    
    - Avaliação de expressões booleanas;
    - Operações matemáticas;
    - Retorno de métodos;
    - Atribuição;
    - Acesso à variáveis e posições arbitrárias de um array
&lt;/pre&gt;

&lt;p&gt;Seguindo esses passos sempre chegamos a uma função que descreve o tempo de execução do algoritmo. Vimos também que estamos interessados na ordem de crescimento dessa função, mais do que nos seus termos detalhados. Isto é, como se comporta a função para grandes valores de $n$. Assim, podemos aplicar as seguintes diretrizes para identificar a classe de complexidade das funções:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Eliminar constantes;&lt;/li&gt;
&lt;li&gt;Eliminar expoentes de menor magnitude.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Desse modo, a função $f(n) = 70n + 32n + 231$ tem ordem de crescimento linear. Isto é, $f(n) \in \Theta(n)$. Lembrando sempre que a maneira formal de demonstrar que $f(n) \in \Theta(n)$ é encontrar $c1$, $c2$ e $n0$, tal que:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0 &lt;= c1*n  &lt;= 70n + 32n + 231 &lt;= c2*n, \forall n &gt;=n0 $ &lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;o-problema&#34;&gt;O Problema&lt;/h1&gt;

&lt;p&gt;Acontece que, para algoritmos recursivos, a aplicação dos passos acima não é direta, pois um algoritmo recursivo é definido em termos dele mesmo. Vamos começar com uma função bem simples: fatorial.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; fatorial(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 1)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 1;
   &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; fatorial(n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vamos tentar aplicar os passos que aprendemos para a análise de algoritmos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Identificando as primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if (n==0 || n == 1)&lt;/code&gt; -&amp;gt; avaliação de expressão booleana.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return 1&lt;/code&gt; -&amp;gt; retorno de método.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return n&lt;/code&gt; -&amp;gt; retorno de método.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; -&amp;gt; operação aritmética.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fatorial(n-1)&lt;/code&gt; -&amp;gt; ?&lt;/p&gt;

&lt;p&gt;Como vimos, para o caso em que as execuções não são em função de $n$ (caso acima) podemos simplificar as operações primitivas e suas execuções para (1).&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;O problema aqui é calcular o custo de fatorial(n-1).&lt;/p&gt;

&lt;p&gt;Qual o custo dessa operação e quantas vezes ela será executada? Não conseguimos responder essa questão de maneira direta como fizemos para os algoritmos iterativos porque trata-se de uma função definida em termos dela mesma. No nosso contexto, funções dessa natureza são chamadas de &lt;strong&gt;relações de recorrência&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;relação-de-recorrência&#34;&gt;Relação de Recorrência&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Relação de recorrência é uma equação ou inequação que descreve uma função em termos dela mesma considerando entradas menores.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A função que descreve o tempo de execução de um algoritmo recursivo é dada por sua relação de recorrência. Vejamos a relação de recorrência que descreve o algoritmo de cálculo do fatorial:&lt;/p&gt;

&lt;p&gt;$T(n) = T(n-1) + \Theta(1)$,&lt;/p&gt;

&lt;p&gt;simplificando temos: $T(n) = T(n-1) + 1$&lt;/p&gt;

&lt;p&gt;Ou seja, o custo de calcular fatorial(n) é o custo de calcular fatorial(n-1) somado às primitivas que são executadas a cada passo da recursão que, nesse caso, representam 1.&lt;/p&gt;

&lt;p&gt;Nosso desafio então é resolver essa relação de recorrência para determinarmos o tempo de execução do algoritmo para cálculo do fatorial. Para isso, vamos utilizar o método da árvore de recursão.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;método-da-árvore-de-recursão&#34;&gt;Método da árvore de recursão&lt;/h1&gt;

&lt;p&gt;A ideia para resolver uma relação de recorrência é simular a sua execução através de uma árvore, onde os nós representam a entrada e as arestas representam a chamada recursiva.&lt;/p&gt;

&lt;h2 id=&#34;exemplo-fatorial&#34;&gt;Exemplo: Fatorial&lt;/h2&gt;

&lt;p&gt;Vamos entender como funciona esse recurso através de exemplos. Veja a árvore de recursão para o cálculo do fatorial de 5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;fatorial.png&#34; alt=&#34;fatorial&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que a raiz da árvore inicia com o valor 5, que é o tamanho da entrada. Note também que o custo do nível da entrada 5 é 1 (as primitivas). Este custo deve ser somado ao custo para a entrada 4 (chamada recursiva) que, por sua vez é 1. O cálculo da entrada 4 deve ser somado ao custo para a entrada 3 (chamada recursiva) e assim por diante. Veja que isso nada mais é do que a reprodução da relação de recorrência $T(n) = T(n-1) + 1$.&lt;/p&gt;

&lt;p&gt;Por fim, não é difícil compreender que o custo total é a soma dos custos de cada nível, ou seja, a soma dos custos de cada passo da recursão.&lt;/p&gt;

&lt;p&gt;Contudo, nosso trabalho aqui é definir o tempo de execução do algoritmo em função de uma entrada de tamanho n qualquer. Vamos, novamente, ilustrar a árvore de recursão para esse cenário:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;fatorialn.png&#34; alt=&#34;fatorialn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Novamente, para calcular a função que define o tempo de execução desse algoritmo, precisamos somar os custos de cada nível. Isto é, somaremos o valor 1 uma quantidade de vezes representada por $h + 1$, onde $h$ é a altura da árvore e o +1 é o custo da última execução (&lt;code&gt;if n == 0 || n == 1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Portanto, precisamos definir $h$. Analisando a árvore, não é difícil notar que $h = n - 1$. Assim, temos que $f(n) = 1 * (n-1) + 1$, isto é, $f(n) = n$. Portanto, podemos dizer que $f(n) \in \Theta(n)$.&lt;/p&gt;

&lt;p&gt;Em resumo, podemos estabelecer os seguintes passos para analisar um algoritmo recursivo:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Estabelecer a relação de recorrência&lt;/li&gt;
&lt;li&gt;Expandir a árvore de execução baseado na relação de recorrência&lt;/li&gt;
&lt;li&gt;Determinar a altura h máxima da árvore&lt;/li&gt;
&lt;li&gt;Somar o custo de cada nível de execução&lt;/li&gt;
&lt;li&gt;Somar o custo total (soma do custo de todos os níveis)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;exemplo-mergesort&#34;&gt;Exemplo: MergeSort&lt;/h2&gt;

&lt;p&gt;Vamos analisar um exemplo um pouco mais complexo. O Merge Sort é um algoritmo de ordenação que, a cada execução parcial, efetua duas chamadas recursivas diminuindo pela metade o tamanho da entrada e um rotina (merge) cujo tempo de execução é dado por $\Theta(n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; mergeSort(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ini&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fim&lt;/span&gt;) {
	If (ini &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; fim) {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;meio&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ini &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fim) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2;
		mergeSort(v, ini, meio);
		mergeSort(v, meio &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1, fim);
		merge(v, ini, meio, fim);
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Relação de recorrência.&lt;/strong&gt; A primeira etapa para identificar a classe de complexidade do &lt;em&gt;Merge Sort&lt;/em&gt; é identificar a sua relação de recorrência:&lt;/p&gt;

&lt;p&gt;$T(n) = T(n/2) + T(n/2) + (n)$, simplificando&lt;/p&gt;

&lt;p&gt;$T(n) = 2 * T(n/2) + n$, onde n = v.length - 1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$2 * T(n/2)$ representa as duas chamadas recursivas em que a entrada é divida pela metade em cada uma delas.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$+ n$ representa o custo da função que une duas sequências já ordenadas em uma sequência ordenada. Não precisamos saber como isso é feito nesse momento, apenas precisamos saber que essa parte do algoritmo tem custo linear.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
Para fixar! Muitas relações de recorrência podem ser descritas 
na seguinte forma:

T(n) = a*T(n/b) + f(n)  , com a&gt;=1, b&gt;1 e f(n) não negativa. 

É importante que a gente saiba em português o que significa essa 
equação acima. Você lembra que ela é referente a um algoritmo 
recursivo, certo? Em português, dizemos que há a chamadas 
recursivas e que cada chamada recursiva divide a entrada em b 
partes. Além disso, a cada chamada recursiva, um custo f(n) é 
adicionado.
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Árvore de Recursão.&lt;/strong&gt; Vamos ilustrar a árvore de recursão gerada pela recorrência $T(n) = 2 T(n/2) + n$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;merge.png&#34; alt=&#34;merge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos notar que a árvore é um pouco diferente da que ilustramos para o fatorial. Em primeiro lugar, a árvore é binária. Sendo assim, o custo de um nível agora é calculado somando-se os custos de cada nó desse nível. Novamente, as arestas representam as duas chamadas recursivas de cada passo. Outra mudança é que cada nó filho diminui na metade o tamanho da entrada do nó pai. Essas duas últimas sentenças são resumidas por $2 * T (n/2)$. Por fim, cada nó tem o seu tempo de execução definido em função linear do tamanho da entrada. Essa última sentença é resumida pela parte final da relação de recorrência &amp;hellip;. $+n$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Função do tempo de execução.&lt;/strong&gt; Agora precisamos somar os custos de todos os níveis. Para isso, assim como no caso do fatorial, precisamos determinar a altura dessa árvore.&lt;/p&gt;

&lt;p&gt;Para o cálculo da altura podemos notar que a árvore irá parar de crescer quando $n / 2^h = 1$, pois o algoritmo atinge a condição de parada ini &amp;gt;= fim.&lt;/p&gt;

&lt;p&gt;Assim, temos que $2^h = n$. Aplicando $\log_{2}2$ nos dois lados da equação, temos:&lt;/p&gt;

&lt;p&gt;$h * \log_{2}2 = \log n$&lt;/p&gt;

&lt;p&gt;Simplificando, temos: $h = \log_{2}n$&lt;/p&gt;

&lt;p&gt;Agora que já definimos a altura da árvore, precisamos somar os custos parciais (de cada nível) uma quantidade de vezes representada pela altura da árvore. Cada nível tem custo $n$ (ex: $2 * n/2$, $4 * n/4$, $8 * n/8$&amp;hellip;). Se somarmos $n$ por 10 vezes, teremos $10*n$. Se somarmos $n$ por 100 vezes, teremos $100*n$. Como vamos somar $n$ por $\log n$ vezes, temos que o tempo de execução desse algoritmo é dado por $f(n) = n * \log n$. Naturalmente, só podemos fazer essa multiplicação porque cada nível tem o mesmo custo n.&lt;/p&gt;

&lt;p&gt;Então, temos que $T(n) =(n * \log n)$.&lt;/p&gt;

&lt;h2 id=&#34;exemplo-busca-binária&#34;&gt;Exemplo: Busca Binária&lt;/h2&gt;

&lt;p&gt;O algoritmo de busca binária é um algoritmo clássico de identificação da posição de um determinado elemento em uma sequência ordenada. A ideia é &amp;ldquo;palpitar&amp;rdquo; sempre a posição central. Caso o palpite seja maior do que o valor sendo procurado, o algoritmo descarta a metade à frente do palpite e passa a procurar na metade que contém os valores menores do que o palpite. Dessa maneira, a cada passo da recursão, são descartados metade dos elementos restantes. Esse procedimento torna a busca binária muito eficiente, quando comparada com a busca linear, que descarta apenas um elemento a cada iteração.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; indexOf(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ini&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fim&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ini &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; fim) {    
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;meio&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ini &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fim;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (v[meio] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; meio;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v[meio])
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; indexOf(v, n, ini, meio &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; indexOf(v, n, meio &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1, fim);
	} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Relação de recorrência.&lt;/strong&gt; Como aprendemos anteriormente, a primeira etapa para identificar o custo de execução do algoritimo de Busca Binária é identificar a sua relação de recorrência:&lt;/p&gt;

&lt;p&gt;$T(n) = T(n/2) + \Theta(1)$.&lt;/p&gt;

&lt;p&gt;Simplificando, $T(n) =  T(n/2) + 1$, onde n = v.length - 1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$T(n/2)$ representa a chamada recursiva em que a entrada é divida pela metade. Importante notar aqui que, embora haja duas chamadas recursivas no código, apenas uma é executada a cada passo. Por isso temos $T(n/2)$ e não $2 * T(n/2)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$+ 1$ representa o custo da operação de cálculo do meio e da avaliação das expressões booleanas.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Árvore de Recursão. Vamos ilustrar a árvore de recursão gerada pela recorrência $T(n) = T(n/2) + 1$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;binaria.png&#34; alt=&#34;binaria&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cada nó da árvore possui apenas uma aresta, porque há apenas uma chamada recursiva. Cada nível tem o seu custo constante (1), uma vez que a cada passo da recursão apenas algumas primitivas são executadas, como as avaliações das expressões booleanas e o cálculo da variável &lt;code&gt;meio&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Função do tempo de execução.&lt;/strong&gt; Agora precisamos somar os custos de todos os níveis. Para isso, assim como nos casos anteriores, precisamos determinar a altura dessa árvore.&lt;/p&gt;

&lt;p&gt;O cálculo da altura é exatamente o mesmo do realizado para o exemplo do Merge Sort. A árvore irá parar de crescer quando $n / 2^h = 1$, pois o algoritmo atinge a condição de parada &lt;code&gt;ini &amp;gt;= fim&lt;/code&gt;. Aplicando os mesmos passos do exemplo anterior, temos que a $h = \log n$&lt;/p&gt;

&lt;p&gt;Agora que já definimos a altura da árvore, precisamos somar os custos parciais (de cada nível) uma quantidade de vezes representada pela altura da árvore. Cada nível tem custo 1. Se somarmos 1 por 10 vezes, teremos $10*1$. Se somarmos 1 por 100 vezes, teremos $100*1$. Como vamos somar 1 por $\log n$ vezes, temos que o tempo de execução desse algoritmo é dado por $f(n) = 1 * \log n$, ou seja, $f(n) = \log n$. Naturalmente, só podemos fazer essa multiplicação porque cada nível tem o mesmo custo 1.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;método-mestre&#34;&gt;Método Mestre&lt;/h1&gt;

&lt;p&gt;O método iterativo utilizando a árvore de recursão é, de fato, uma boa alternativa para identificar a classe de complexidade de algoritmos recursivos. Além de ser um método analítico, ele tem propriedades didáticas importantes. Isto é, o exercício de ilustrar a árvore de recursão (execução) e, a partir dela, identificar o custo total do algoritmo é importante não somente para esse fim, mas para exercitar a capacidade de abstração e raciocínio do aluno. Contudo, muitas vezes, trata-se de um mecanismo laborioso. Nesse contexto, surge o &lt;strong&gt;Teorema Mestre&lt;/strong&gt; que nos permite identificar a classe de complexidade de um algoritmo aplicando apenas algumas operações matemáticas e comparando ordem de complexidade de funções.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E como o teorema funciona?&lt;/strong&gt; Primeiramente, é preciso que a relação de recorrência tenha determinadas propriedades. Vamos analisar concretamente essas propriedades:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$T(n) = a*T(n/b) + f(n)$&lt;/p&gt;

&lt;p&gt;Sendo $a&amp;gt;=1$, $b&amp;gt;1$ e $f(n)$ não negativa.&lt;/p&gt;

&lt;p&gt;Como vimos anteriormente, $a$ representa a quantidade de chamadas recursivas (quantidade de subproblemas), $b$ representa em quanto a entrada é diminuída a cada chamada recursiva e $f(n)$ representa o custo parcial de cada etapa da recursão. Para aplicar o Teorema Mestre, sua relação de recorrência deve ser na forma acima com $a &amp;gt;= 1$, $b &amp;gt; 1$ e $f(n)$ não negativa.&lt;/p&gt;

&lt;p&gt;Para esses casos, o Teorema Mestre é uma maneira direta de resolvermos a relação de recorrência. O Teorema Mestre estabelece que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Se f(n) &amp;lt; n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, então T(n) = theta(n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Se f(n) = n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, então T(n) = theta(f(n) * log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;n&lt;/sup&gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Se f(n) &amp;gt; n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, então T(n) = theta(f(n)).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Desse modo, se a relação de recorrência obedecer às restrições $a&amp;gt;=1$, $b&amp;gt;1$ e $f(n)$ não negativa, basta aplicarmos o teorema.&lt;/p&gt;

&lt;h3 id=&#34;exemplo&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Para a relação de recorrência $T(n) = 8 * T(n/2) + 1000 * n^2$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$a = 8$&lt;/li&gt;
&lt;li&gt;$b = 2$&lt;/li&gt;
&lt;li&gt;$f(n) = 1000 * n^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comparando $1000 * n^2$  com  n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, temos que $1000 * n^2$ &amp;lt; $n^3$. Portanto, aplicando a primeira regra do Teorema Mestre, podemos afirmar que T(n) = theta(n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;) e, portanto, $T(n) = (n^3)$.&lt;/p&gt;

&lt;h3 id=&#34;exemplo-1&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;$T(n) = 2 * T(n/2) + 10*n$&lt;/p&gt;

&lt;p&gt;Para a relação acima, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$a = 2$&lt;/li&gt;
&lt;li&gt;$b = 2$&lt;/li&gt;
&lt;li&gt;$f(n) = 10 * n$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comparando $10 * n$ com n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt; temos que $10 * n  =  n$, pois comparamos a ordem de grandeza das funções e, quando fazemos isso, as constantes não importam. Portanto, aplicando a segunda regra do Teorema Mestre, podemos afirmar que $T(n) = \Theta(n * \log_{2}n)$.&lt;/p&gt;

&lt;h3 id=&#34;exemplo-2&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Para $T(n) = 2 * T(n/2) + n^2$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$a = 2$&lt;/li&gt;
&lt;li&gt;$b = 2$&lt;/li&gt;
&lt;li&gt;$f(n) = n^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comparando $n^2$  com n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt; temos que $n^2 &amp;gt; n$. Portanto, aplicando a terceira regra do Teorema Mestre, podemos afirmar que $T(n) = \Theta(f(n))$ e, portanto, $T(n) = \Theta(n^2)$.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Este material é um resumo superficial do Capítulo 4 do livro &amp;ldquo;Algoritmos: Teoria e Prática&amp;rdquo; de Cormen et. al.&lt;/p&gt;

&lt;p&gt;Há outras implementações de fatorial. Por exemplo, ao invés de checar se n == 0 ou n == 1, bastaria apenas checar se n == 0, 1 * 1 == 1. Dessa forma, a altura da árvore gerada teria uma unidade a mais. Contudo, isso não impacta na ordem de grandeza do algoritmo.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Ordenação Linear</title>
         <link>https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/</link>
         <pubDate>Sun, 27 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Os algoritmos de ordenação que vimos até então utilizam comparação para estabelecer a ordem entre os elementos de uma sequência. Primeiro vimos três algoritmos $\Theta(n^2)$: Selection Sort, Insertion Sort e Bubble Sort. Depois vimos alguns algoritmos $\Theta(n * \log n)$: Merge Sort e Quick Sort&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Importante-lembr&#34;&gt;&lt;a href=&#34;#fn:Importante-lembr&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Neste material vamos abordar algoritmos que não utilizam comparação, mas que são muito eficientes do ponto de vista de tempo de execução, embora demandem substancialmente mais memória do que o Selection Sort, Insertion Sort, Quick Sort etc.&lt;/p&gt;

&lt;h1 id=&#34;ordenação-por-contagem&#34;&gt;Ordenação por Contagem&lt;/h1&gt;

&lt;p&gt;Algo que chama a atenção em um primeiro momento é:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;b&gt;Como é possível ordenar elementos sem utilizar comparação?&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Em geral, a ideia é valer-se do fato de que estamos ordenando números inteiros e que os índices dos arrays também são inteiros. Dessa maneira, podemos mapear o valor presente em uma sequência para a posição de mesmo valor em um array auxiliar (&lt;code&gt;array[i] = i&lt;/code&gt;). Essa é a estratégia geral dos algoritmos de ordenação linear que se baseiam na contagem dos elementos da sequência a ser ordenada.&lt;/p&gt;

&lt;p&gt;Antes de analisarmos os algoritmos de contagem em detalhes, vamos abordar um exemplo bem simples para entender esse conceito. Para isso, vamos entrar em um mundo em que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;todos os elementos do array que vamos ordenar são inteiros positivos (1, 2, 3…k);&lt;/li&gt;
&lt;li&gt;não há repetição de elementos no array que vamos ordenar;&lt;/li&gt;
&lt;li&gt;sabemos o maior valor desse array, o qual chamamos de k.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Desse modo, se quisermos ordenar o array $A = [7, 2, 1, 4]$&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:O-ideal-nomear-v&#34;&gt;&lt;a href=&#34;#fn:O-ideal-nomear-v&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, basta criarmos um array auxiliar $C$ cujo tamanho é $k$, onde $k$ é o maior elemento do array original (7), e iterarmos sobre $A$ registrando a presença de seus elementos em $C$ através da seguinte instrução &lt;code&gt;C[A[i] - 1] = true&lt;/code&gt;. O índice é subtraído de 1, pois as posições de um array em Java iniciam-se de 0.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[k];

&lt;span style=&#34;color:#75715e&#34;&gt;// registrando a presença de A[i] na sequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Se $A = [7, 2, 1, 4]$, com $k = 7$, temos $C$ preenchido da seguinte maneira:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C = [&lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Agora, se criarmos um array $B$ do tamanho de $A$ e iterarmos sobre o array $C$ preenchendo $B$ com o valor do índice $i + 1$ em que &lt;code&gt;C[i] == true&lt;/code&gt;, temos que $B$ é a versão ordenada de $A$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (C[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;) {
        B[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;
        j &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Assim, para $A = [7, 2, 1, 4]$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C = [&lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;]&lt;/li&gt;
&lt;li&gt;B = [1, 2, 4, 7], representando a sequência de valores de $A$, porém ordenada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Viu como foi fácil? Note que $B$ foi preenchido com os valores de $i+1$ em que C[i] ==  true. Ou seja, $B[0] = 1$, pois C[0] ==  true. $B[1] = 2$, pois C[1] ==  true. $B[2] = 4$, pois C[3] ==  true. Por fim, $B[3] = 7$, pois C[6] ==  true.&lt;/p&gt;

&lt;p&gt;Vamos unir os trechos de código mostrados acima em um método que recebe $A$ e $k$ e retorna um array $B$ que representa a ordenação dos elementos de $A$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;) {
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[k];

    &lt;span style=&#34;color:#75715e&#34;&gt;// registrando a presença de A[i] na sequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    }
   
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (C[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;) {
            B[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;
            j &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; B;   
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;mais-um-exemplo-a-9-1-3-4-6-7&#34;&gt;Mais um exemplo: A = [9, 1, 3, 4, 6, 7]&lt;/h3&gt;

&lt;p&gt;Sempre lembrando que sabemos o valor de $k$ e que não há repetição dos elementos a serem ordenados.&lt;/p&gt;

&lt;p&gt;Para $A = [9, 1, 3, 4, 6, 7]$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C = [&lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;,  &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false,  &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;B = [1, 3, 4, 6, 7, 9], representando a sequência de valores de $A$, porém ordenada.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;counting-sort-e-se-houver-repetição-no-array&#34;&gt;Counting Sort: E se houver repetição no array?&lt;/h2&gt;

&lt;p&gt;Repetição de valores em um array a ser ordenado não é um cenário incomum, certo? O fato de não haver repetição nos permitiu criar um array C de booleanos e registrar a presença ou não de um elemento.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;O que faríamos se houvesse repetição?&lt;/p&gt;

&lt;p&gt;Daí surge ordenação por contagem (&lt;em&gt;Counting Sort&lt;/em&gt;). A ideia geral é registrar a frequência dos elementos ao invés da simples presença. Isso faz com que o array $C$ passe a ser um array de inteiros, não de booleanos. O algoritmo do &lt;em&gt;Counting Sort&lt;/em&gt; é baseado na ideia que vimos, mas possui algumas modificações substanciais para permitir elementos repetidos e para manter a estabilidade. Em linhas gerais, o &lt;em&gt;Counting Sort&lt;/em&gt; possui os seguintes passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;registrar a frequência dos elementos de $A$ no array $C$;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calcular a soma cumulativa de $C$. Esse passo registra, para cada elemento $x$ da entrada, o número de elementos menores ou iguais a $x$;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iterar sobre $A$ do fim ao início registrando em $B$ o valor de $A$ com a seguinte instrução &lt;code&gt;B[C[A[i] - 1] -1] = A[i]&lt;/code&gt;. Não se assuste. Essa sequência de decrementos em 1 é devido ao fato de começarmos os índices de um array a partir de zero em Java.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Antes de entrarmos nos detalhes de código do algoritmo, vamos simular a execução de um exemplo.&lt;/p&gt;

&lt;h3 id=&#34;exemplo-a-1-9-1-3-4-7-6-7&#34;&gt;Exemplo: A = [1, 9, 1, 3, 4, 7, 6, 7]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Passo 1: Contagem de frequência em C.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[k];

        &lt;span style=&#34;color:#75715e&#34;&gt;// frequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Para  $A = [1, 9, 1, 3, 4, 7, 6, 7]$ e $k = 9$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C = [2, 0, 1, 1, 0, 1, 2, 0, 1], isto é, no array a ser ordenado há dois elementos de valor 1, nenhum elemento de valor 2, um elemento de valor 3 e assim por diante.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Soma cumulativa em C.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
        &lt;span style=&#34;color:#75715e&#34;&gt;// cumulativa
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[i] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; C[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1];
        }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Para $C = [2, 0, 1, 1, 0, 1, 2, 0, 1]$, após a execução do cálculo da cumulativa, temos $C = [2, 2, 3, 4, 4, 5, 7, 7, 8]$, isto é, no array a ser ordenado há:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2 elementos menores ou igual a 1&lt;/li&gt;
&lt;li&gt;2 elementos menores ou iguais a 2&lt;/li&gt;
&lt;li&gt;3 elementos menores ou iguais a 3&lt;/li&gt;
&lt;li&gt;4 elementos menores ou iguais a 4&lt;/li&gt;
&lt;li&gt;4 elementos menores ou iguais a 5&lt;/li&gt;
&lt;li&gt;5 elementos menores ou iguais a 6&lt;/li&gt;
&lt;li&gt;7 elementos menores ou iguais a 7&lt;/li&gt;
&lt;li&gt;7 elementos menores ou iguais a 8&lt;/li&gt;
&lt;li&gt;8 elementos menores ou iguais a 9.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Iterar do fim ao início de $A$ registrando em $B$ os elementos.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
            B[C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i];
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
        }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Essa parte pode ser confusa e acredito que para entendê-la precisamos de recursos visuais melhores do que o texto. Por isso, fiz o vídeo abaixo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=3bm7NgKJpj4&amp;feature=youtu.be&#34;&gt;
    &lt;img src=&#34;video.jpg&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;implementação-do-counting-sort&#34;&gt;Implementação do Counting Sort&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;countingSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;) {
    
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[k];

        &lt;span style=&#34;color:#75715e&#34;&gt;// frequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        }
        
        &lt;span style=&#34;color:#75715e&#34;&gt;// cumulativa
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[i] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; C[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1];
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
            B[C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i];
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; B;
    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;análise-do-counting-sort&#34;&gt;Análise do Counting Sort&lt;/h2&gt;

&lt;p&gt;O Counting Sort tem em sua implementação 3 laços principais. O primeiro percorre o array $A$ (tamanho $n$), o segundo percorre o array $C$ (tamanho $k$) e o terceiro percorre novamente o array $A$. Assim, temos:&lt;/p&gt;

&lt;p&gt;$T(n) = 2n + k$. Aplicando as diretrizes para análise assintótica, temos:
$T(n) = (n + k)$.&lt;/p&gt;

&lt;p&gt;O importante aqui é entender que o algoritmo tem seu tempo de execução linear em função do tamanho de $n$ e $k$, não somente do tamanho de $n$. Esse tempo de execução é substancialmente mais eficiente do que os outros algoritmos que vimos. Contudo, esse algoritmo também tem um custo associado ao uso de memória, pois precisa criar um array de contagem $C$ de tamanho igual a $k$ e o array $B$ a ser retornado de tamanho igual ao do array original. Ou seja, do ponto de vista de memória, também que o consumo é dado por $T(n) = (n + k)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O que acontece se k for muito maior que n?&lt;/strong&gt; Vejamos um exemplo:&lt;/p&gt;

&lt;p&gt;$A = [1, 3, 2, 1, 9874392]$&lt;/p&gt;

&lt;p&gt;Veja que teríamos que criar o array de contagem $C$ de tamanho 9874392 mesmo tendo que ordenar apenas 5 elementos, o que seria muito ruim.&lt;/p&gt;

&lt;p&gt;Por outro lado, o que acontece se $k$ for muito menor que $n$? Vejamos um exemplo:&lt;/p&gt;

&lt;p&gt;A = [1, 3, 2, 1, 1, 5, 3, 2, 5, 4, 2, 1, 2, 1, 1, 2, 1, 4, 5, 2, 2, 3, 2]&lt;/p&gt;

&lt;p&gt;Veja que teríamos que criar o array de contagem C de tamanho 5 para ordenar um array com 23 elementos.  Isso pode ser ainda mais vantajoso se imaginarmos um cenário em que teremos, por exemplo, que ordenar todas as pessoas do mundo de acordo com sua idade. Nesse caso, temos um conjunto muito grande de dados (~7.7 bilhões), mas com um $k$ bem menor, pois a pessoa mais velha do mundo não ultrapassaria, nos dias de hoje, 125 anos. Isto é, $k$ é muito menor do que $n$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E se eu quiser usar o Counting Sort para ordenar sequências contendo valores iguais a zero e valores negativos?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O Counting Sort baseia-se na ideia de que um valor inteiro pode ser mapeado para o índice de mesmo valor em um array auxiliar. Essa estratégia nos impede, em um primeiro momento, de ordenar uma sequência com números negativos, pois o menor índice em um array é 0. Além disso, na nossa implementação inicial excluímos também elementos iguais a zero. Contudo, é possível fazer algumas mudanças simples no Counting Sort para que o mesmo passe a também ordenar sequências com esses valores.&lt;/p&gt;

&lt;p&gt;A ideia é simples: basta identificarmos o menor elemento do array (menor) e usar esse valor como um &amp;ldquo;salto&amp;rdquo; para adicionar os elementos. É uma ideia similar a fazer um shift para a direita em todos os elementos. O menor elemento array tem sua frequência registrada na posição zero. Vamos ver um exemplo:&lt;/p&gt;

&lt;p&gt;$A = [1,-3, 2, 1, 7]$, com k = 7 e menor = -3.&lt;/p&gt;

&lt;p&gt;Em primeiro lugar, o array de contagem $C$ já não varia de 0 a $k$, mas sim de 0 a $k - menor + 1$, porque temos que considerar que a frequência do elemento de valor -3 será registrada na posição 0, a do valor -2, na posição 1, a do valor -1 na posição 0 e assim por diante. Por isso, quando for preciso mapear os elementos de A em C e B, temos que usar o salto de |menor| (3, no nosso exemplo). O cálculo da frequência seria dado pelo seguinte código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[maior &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; menor &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1];

    &lt;span style=&#34;color:#75715e&#34;&gt;// frequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; menor] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Para A = [1,-3, 2, 1, 7], temos C = [1, 0, 0, 0, 2, 1, 0, 0, 0, 0, 1]. Note que o primeiro índice é reservado para a frequência do menor elemento (-3) e não mais para 1. Além disso, como estamos também contando com a presença de elementos de valor 0 no array, trocamos a instrução &lt;code&gt;C[A[i] - 1] += 1&lt;/code&gt; por &lt;code&gt;C[A[i] - menor] += 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A mesma mudança é considerada no restante da implementação, sempre aplicando &lt;code&gt;array[i]- menor&lt;/code&gt; para considerar o salto.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Este material não é tão completo quanto o livro texto da disciplina. Sugiro também a leitura do Capítulo 8 do livro &amp;ldquo;Algoritmos: Teoria e Prática&amp;rdquo; de Cormen et. al.&lt;/p&gt;

&lt;p&gt;No curso de Estrutura de Dados da UFCG há ainda a discussão de outros algoritmos de ordenação linear, como o Radix Sort e o Bucket Sort.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Importante-lembr&#34;&gt;Importante lembrar que o Quick Sort no pior caso tem seu tempo de execução descrito por uma função quadrática. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Importante-lembr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:O-ideal-nomear-v&#34;&gt; O ideal é nomear variável com letra minúscula em Java. Contudo, para fins didáticos, utilizaremos letras maiúsculas. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:O-ideal-nomear-v&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Listas Baseadas em Arrays (ArrayList)</title>
         <link>https://joaoarthurbm.github.io/eda/posts/arraylist/</link>
         <pubDate>Sat, 26 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/arraylist/</guid>
         <description>

&lt;p&gt;&lt;aside&gt;&lt;i class=&#34;fab fa-github fa-lg&#34; aria-hidden=&#34;true&#34;&gt; &lt;/i&gt; &lt;a href=&#34;https://github.com/joaoarthurbm/eda-ufcg/tree/master/java/src/arraylist&#34;&gt; &lt;font color=&#34;#1980e6&#34;&gt; &lt;b&gt;Código utilizado nesta aula&lt;/b&gt;&lt;/font&gt;&lt;/a&gt;&lt;/aside&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Array é a primeira estrutura de dados que abordamos na disciplina. Há razões para essa escolha. Em primeiro lugar, arrays estão presentes na biblioteca padrão de grande parte das linguagens de programação. Além disso, também são estruturas simples e eficientes. Por último, outras estruturas mais complexas baseiam sua implementação em arrays, como é o caso de ArrayList, assunto deste material.&lt;/p&gt;

&lt;p&gt;Antes de partirmos para os detalhes de ArrayList, vamos destacar algumas desvantagens na manipulação de arrays que nos motivam a construir ArrayList. Todas essas desvantagens compartilham um incômodo comum: o programador deve ser responsável por diversas verificações e operações adicionais para manter a consistência do array. Vejamos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O array possui tamanho fixo.&lt;/strong&gt; Caso seja preciso armazenar mais elementos, é preciso criar um outro e transferir os elementos do array original para esse novo array. Isso não é algo que o programador queira se preocupar sempre. Por isso é preciso que isso seja feito de forma transparente para quem deseja usar uma estrutura de dados que cresce &amp;ldquo;dinamicamente&amp;rdquo;. O tamanho fixo também implica dizer que nem sempre a quantidade de elementos presentes no array é igual a sua capacidade. Por isso, o programador também tem que controlar quantas posições estão, de fato, sendo utilizadas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Não é possível remover uma posição do array.&lt;/strong&gt; O que fazemos, normalmente, é atribuir aquela posição para null. Contudo, isso cria um &amp;ldquo;buraco&amp;rdquo; no array. O programador deve decidir se afasta todos os outros objetos para a esquerda ou se convive com aquele &amp;ldquo;buraco&amp;rdquo;. Conviver nesse contexto significa espalhar pelo código verificações como &lt;code&gt;if alunos[i] != null&lt;/code&gt;. Novamente, idealmente o programador não precisaria se preocupar com isso. Isso deveria ser transparente para quem está usando uma estrutura de dados.&lt;/p&gt;

&lt;p&gt;Então, em resumo, como já vimos no passado, array é uma estrutura eficiente da qual queremos tirar proveito, mas muitas das preocupações que estão incluídas no seu uso podem ser transparentes para o programador. Essa é a proposta da classe ArrayList: fornecer uma API com operações de uma lista, mas esconder detalhes como remanejamento de elementos na remoção, aumento da capacidade da estrutura na adição de elementos, entre outras tarefas.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;arraylist&#34;&gt;ArrayList&lt;/h1&gt;

&lt;p&gt;Para fins didáticos, neste material vamos construir uma lista baseada em arrays que armazena objetos do tipo Aluno. O objeto do tipo Aluno possui dois atributos: matrícula e nome. A partir de agora, instâncias desse tipo serão representadas pela notação (matrícula, nome), por exemplo, (123, &amp;ldquo;Cartola&amp;rdquo;).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; Aluno {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Integer&lt;/span&gt; matricula;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; nome;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Integer&lt;/span&gt; getMatricula() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;matricula&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; getNome() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;nome&lt;/span&gt;;
    }
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;organização-interna-atributos-constantes-e-construtores&#34;&gt;Organização interna: atributos, constantes e construtores&lt;/h2&gt;

&lt;p&gt;Vamos lá.  Em primeiro lugar, vamos dar uma olhada na definição da classe, seus atributos e construtores:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; ArrayList {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt;[] lista;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; CAPACIDADE_DEFAULT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 20;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; tamanho;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ArrayList&lt;/span&gt;() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;(CAPACIDADE_DEFAULT);
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ArrayList&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;capacidade&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[capacidade];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    }

           ...

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Um objeto do tipo ArrayList possui dois atributos: o array &lt;strong&gt;&lt;em&gt;lista&lt;/em&gt;&lt;/strong&gt;, que armazena os objetos e o inteiro &lt;em&gt;tamanho&lt;/em&gt;, que representa a quantidade de elementos presente na lista. A classe ArrayList possui também uma constante &lt;strong&gt;&lt;em&gt;CAPACIDADE_DEFAULT&lt;/em&gt;&lt;/strong&gt; que define em 20 a capacidade inicial da lista, caso o programador não queira redefini-la. Por fim, dois construtores são definidos: um padrão, caso o programador não queira redefinir o tamanho inicial da lista e um recebendo como parâmetro a capacidade desejada.&lt;/p&gt;

&lt;h2 id=&#34;operações-básicas-inserção-remoção-e-busca&#34;&gt;Operações básicas: inserção, remoção e busca.&lt;/h2&gt;

&lt;h3 id=&#34;inserção&#34;&gt;Inserção&lt;/h3&gt;

&lt;p&gt;Há três formas de se inserir um elemento em uma ArrayList:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;boolean add(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void add(int index, Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void set(int index, Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Todas, naturalmente, recebem como parâmetro o elemento a ser adicionado. A primeira não requer um índice específico e, por isso, assume que a inserção do novo elemento deve ser feita no fim da lista, isto é, na próxima posição livre do array. As outras duas formas requerem o índice &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; em que a operação deve ser realizada. A diferença entre essas duas últimas é que uma inclui o novo elemento na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; e desloca os elementos à frente uma posição para a direita, enquanto a outra altera o valor da posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Há uma preocupação interna para os métodos 1 e 2. Para ambos, é preciso checar se o array já não está completamente preenchido. Caso isso seja verdade, precisamos criar um novo array, adicionar todos os elementos do array original nesse novo array e aí sim inserir o novo elemento. Estamos chamando essa rotina de &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Para o método 2 precisamos também deslocar os elementos a frente da posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; para a direita (&lt;strong&gt;&lt;em&gt;shiftParaDireita()&lt;/em&gt;&lt;/strong&gt;) para então incluir o elemento na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Por fim, as estratégias 2 e 3 precisam verificar se o índice a ser alterado é válido ou não, isto é, se está dentro dos limites da lista.&lt;/p&gt;

&lt;p&gt;Vamos ao código.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; add(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        assegureCapacidade(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    }
    

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; add(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
        assegureCapacidade(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1);
        
        shiftParaDireita(index);
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[index] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; set(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[index] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; shiftParaDireita(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; index; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1];
        }
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Estamos tentando seguir o padrão da API de Java para a assinatura dos métodos. Por isso o primeiro método retorna um booleano para indicar se a adição foi feita ou não. Pode parecer estranho porque o retorno é sempre &lt;strong&gt;&lt;em&gt;true&lt;/em&gt;&lt;/strong&gt;, mas isso faz sentido porque essa assinatura é herdada do contrato da interface &lt;strong&gt;&lt;em&gt;List&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;É importante discutir a chamada ao método &lt;strong&gt;&lt;em&gt;assegureCapacidade(int capacidadePretendida)&lt;/em&gt;&lt;/strong&gt;. Por ser baseada em array, uma &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt; é limitada ao tamanho do array definido inicialmente. Caso queira crescer dinamicamente, é preciso checar se há a capacidade pretendida e, se não houver, realizar o resize. Isto é, criar um novo array e transferir os elementos do array inicial para o novo. Ambos os métodos são privados, pois a ideia é que essas preocupações sejam internas e transparentes ao usuário de uma &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt;. Vamos ver como isso é feito:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; assegureCapacidade(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;capacidadePretendida&lt;/span&gt;) {    
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (capacidadePretendida &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;)
            resize(Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 2, capacidadePretendida));
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; resize(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;novaCapacidade&lt;/span&gt;) {
        Aluno[] &lt;span style=&#34;color:#a6e22e&#34;&gt;novaLista&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno[novaCapacidade];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            novaLista[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; novaLista;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;assegureCapacidade.&lt;/strong&gt; Este método verifica se a nova capacidade pretendida é atendida pelo tamanho atual da lista. Caso não seja, o método invoca &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; para criar uma nova lista cujo tamanho o máximo entre o dobro da lista original ou a capacidade nova pretendida. Esse cálculo do máximo entre os dois é feito porque queremos evitar realizar muitos &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; e, por isso, fazemos um &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; de no mínimo o dobro do tamanho original.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;resize.&lt;/strong&gt; Este método cria um novo array e transfere os elementos do array original para ele.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;análise de desempenho&lt;/strong&gt; dessas operações precisa levar em consideração dois fatores: o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; e o &lt;strong&gt;&lt;em&gt;shiftParaADireita()&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Não podemos afirmar que o método &lt;strong&gt;&lt;em&gt;add(Aluno aluno)&lt;/em&gt;&lt;/strong&gt; é executado em tempo constante, mesmo que grande parte das vezes isso seja verdade. Por exemplo, para uma lista de tamanho original 20, as 20 primeiras adições são executadas em tempo constante, mas a 21 primeira precisa executar o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt;, que é realizado em $O(n)$, pois envolve iterar por todo o array antigo e transferir os elementos para o novo array. Contudo, também não podemos dizer que o método &lt;strong&gt;&lt;em&gt;add(Aluno aluno)&lt;/em&gt;&lt;/strong&gt; é $O(n)$, pois o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; é executado apenas quando o limite é alcançado. Nesse caso, dizemos a operação é $O(1)$ amortizado, ou seja, o custo para adicionar $n$ elementos na lista é $O(n)$.&lt;/p&gt;

&lt;p&gt;Para a análise do método &lt;strong&gt;&lt;em&gt;add(int index, Aluno aluno)&lt;/em&gt;&lt;/strong&gt; temos que levar em consideração que o &lt;strong&gt;&lt;em&gt;shiftParaADireita&lt;/em&gt;&lt;/strong&gt; no pior caso é $O(n)$. Esse pior caso se manifesta quando queremos adicionar um elemento no índice 0 da lista. Assim, teríamos que iterar sobre todo o array deslocando os elementos para frente.&lt;/p&gt;

&lt;h3 id=&#34;remoção&#34;&gt;Remoção&lt;/h3&gt;

&lt;p&gt;Há duas formas de se remover um elemento em uma &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt;: pelo índice e pelo valor.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;remove(int index)&lt;/li&gt;
&lt;li&gt;remove(Aluno aluno)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ambos precisam rearranjar os elementos para não deixar &amp;ldquo;buracos&amp;rdquo; na lista. Chamamos essa rotina de &lt;strong&gt;&lt;em&gt;shiftParaEsquerda&lt;/em&gt;&lt;/strong&gt;. A diferença é que o método 2 precisa procurar o elemento antes de realizar o &lt;em&gt;shift&lt;/em&gt;. Veja o exemplo abaixo para entender o porquê de termos que afastar para a esquerda todos os elementos à frente do removido.&lt;/p&gt;

&lt;p&gt;$lista = [9, 2, 1, 8, 24, 3, -7]$, com tamanho = 7.&lt;/p&gt;

&lt;p&gt;Se quisermos remover o elemento no índice 2, precisamos afastar para a esquerda os elementos à frente e atualizar, naturalmente, a variável &lt;strong&gt;&lt;em&gt;tamanho&lt;/em&gt;&lt;/strong&gt;. Após a execução do método &lt;strong&gt;&lt;em&gt;remove(2)&lt;/em&gt;&lt;/strong&gt;, temos a lista nas seguintes condições:&lt;/p&gt;

&lt;p&gt;$lista = [9, 2, 8, 24, 3, -7, -7]$, com $tamanho = 6$, isto é, a última posição (6) passa a estar livre para uma nova adição, caso seja preciso. Perceba que os índices 0 e 1 ficaram inalterados e, a partir disso, o índice $i$ passou a receber o valor em $i+1$. Note também que o último índice fica com o valor anterior, mas ele não faz parte da lista, pois os limites são 0 e $tamanho - 1$. Vamos ao código.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...           
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        
        Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(index);
        
        shiftParaEsquerda(index);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; remove(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aluno &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i].&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno)) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(i);
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
            }
        }
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; shiftParaEsquerda(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; index; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;1];
        }
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Novamente, a preocupação em rearranjar os elementos é exclusiva de quem desenvolveu a lista, não de quem está usando-a.&lt;/p&gt;

&lt;p&gt;Como a remoção envolve realocar todos os elementos à frente do removido para a esquerda, a operação, no pior caso, é $O(n)$. Esse pior caso se manifesta quando queremos remover o primeiro elemento da lista.&lt;/p&gt;

&lt;h3 id=&#34;busca&#34;&gt;Busca&lt;/h3&gt;

&lt;p&gt;De um modo geral, podemos dizer que há 3 cenários de busca: i) quando queremos acessar o elemento em um determinado índice; ii) quando queremos encontrar o índice em que um elemento está e iii) quando queremos verificar a presença de um elemento na lista. Essas aspirações podem ser satisfeitas pelos seguintes métodos:&lt;/p&gt;

&lt;p&gt;Aluno get(int index)
int indexOf(Aluno aluno)
boolean contains(Aluno aluno)&lt;/p&gt;

&lt;p&gt;O método 1 é executado em tempo constante O(1), pois o índice é fornecido como parâmetro. A única preocupação é verificar se o índice é válido ou não.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[index];
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Os outros dois métodos são instâncias de busca linear $(O(n))$, pois devem iterar sobre a lista procurando pelo objeto passado como parâmetro.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...            
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; indexOf(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; tamanho; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i].&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno))
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; i;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; contains(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indexOf&lt;/span&gt;(aluno) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O método &lt;strong&gt;&lt;em&gt;indexOf&lt;/em&gt;&lt;/strong&gt; itera sobre a lista procurando um elemento igual ao passado como parâmetro. Se encontrar, retorna o índice desse elemento. Ou seja, se houver mais de uma ocorrência do valor procurado, o índice da primeira ocorrência é retornado. Caso contrário, retorna -1.&lt;/p&gt;

&lt;p&gt;O método &lt;strong&gt;&lt;em&gt;contains&lt;/em&gt;&lt;/strong&gt; utiliza a rotina efetuada pelo método &lt;strong&gt;&lt;em&gt;indexOf&lt;/em&gt;&lt;/strong&gt;. Caso o índice retornado seja igual a -1, retorna &lt;em&gt;false&lt;/em&gt;. Caso contrário, retorna &lt;em&gt;true&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Por motivos de simplificação, a classe &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt; que implementamos neste material implementa uma lista baseada em arrays para manipular objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;. Naturalmente, por ser de propósito geral, a implementação de Java de &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt; permite o armazenamento e manipulação de qualquer objeto.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Listas Ligadas (LinkedList)</title>
         <link>https://joaoarthurbm.github.io/eda/posts/linkedlist/</link>
         <pubDate>Fri, 25 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/linkedlist/</guid>
         <description>

&lt;p&gt;&lt;aside&gt;&lt;i class=&#34;fab fa-github fa-lg&#34; aria-hidden=&#34;true&#34;&gt; &lt;/i&gt; &lt;a href=&#34;https://github.com/joaoarthurbm/eda-ufcg/tree/master/java/src/linkedlist&#34;&gt; &lt;font color=&#34;#1980e6&#34;&gt; &lt;b&gt;Código utilizado neste material&lt;/b&gt;&lt;/font&gt;&lt;/a&gt;&lt;/aside&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;problemas&#34;&gt;Problemas&lt;/h1&gt;

&lt;p&gt;No &lt;a href=&#34;http://joaoarthurbm.github.io/eda/posts/arraylist&#34;&gt;material sobre ArrayLists&lt;/a&gt; discutimos algumas preocupações oriundas do uso de arrays e que estão todas conceitualmente relacionadas ao fato de que o array é uma estrutura de tamanho fixo. Isso impede o seu crescimento de forma dinâmica. Sempre que for preciso crescer a capacidade de um array é preciso criar um novo e transferir todos os elementos do array original para essa nova instância, o que é uma operação com tempo de execução $O(n)$.&lt;/p&gt;

&lt;p&gt;O fato do array ter tamanho fixo também implica em operações de remanejamento de elementos durante a inserção em uma posição arbitrária (&lt;strong&gt;&lt;em&gt;shiftParaADireita&lt;/em&gt;&lt;/strong&gt;) e durante a remoção de um elemento (&lt;strong&gt;&lt;em&gt;shiftParaAEsquerda&lt;/em&gt;&lt;/strong&gt;), ambas com tempo de execução $O(n)$.&lt;/p&gt;

&lt;p&gt;Por último, por definirmos de antemão o tamanho da estrutura, é possível que a quantidade de elementos no array seja menor do que a sua capacidade. Esse pode ser um problema de menor magnitude e importância atualmente porque a memória &amp;ldquo;desperdiçada&amp;rdquo; pode ser considerada irrelevante. Contudo, conceitualmente é importante discutir esse fato porque o uso indiscriminado de memória, quando cumulativo, pode gerar problemas.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;LinkedLists&lt;/em&gt;&lt;/strong&gt; podem ser vistas como contraponto à estruturas baseadas em arrays. &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; são listas dinâmicas. Ao contrário de estruturas baseadas em arrays, os objetos de uma &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; são criados e removidos sob demanda.&lt;/p&gt;

&lt;h3 id=&#34;como-isso-é-feito&#34;&gt;Como isso é feito?&lt;/h3&gt;

&lt;p&gt;Através da criação de objetos que possuem referências para seus vizinhos. Ou seja, encadeando os objetos. Daí o nome de lista encadeada.&lt;/p&gt;

&lt;h3 id=&#34;e-que-objetos-são-esses&#34;&gt;E que objetos são esses?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Nós.&lt;/strong&gt; Criamos nós que guardam a informação que queremos manipular e referências para seus vizinhos, que são do mesmo tipo. No nosso caso, vamos guardar objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;, que possuem matrícula e nome. Contudo, para fins didáticos, na visualização vamos identificar apenas com um número inteiro. Vamos ao código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; {
    
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }   
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Esta é uma classe auxiliar com visibilidade &lt;em&gt;default&lt;/em&gt; e criada dentro do mesmo arquivo da classe &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt;. Tomei essa decisão de projeto para evitar a manipulação verborrágica de referências através de &lt;strong&gt;&lt;em&gt;getNext()&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;setNext()&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Visualmente, objetos do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; podem ser representados da seguinte maneira:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node exemploNode = new Node(new Aluno(8, &amp;quot;João&amp;quot;));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;node.png&#34; alt=&#34;node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vamos descrever bem o que cada coisa significa. Primeiro, estamos chamando de valor o objeto do tipo aluno armazenado no &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; (representado apenas por um número inteiro). O valor pode ser um objeto de qualquer tipo, pois a lista é uma estrutura de propósito geral. Escolhemos o tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt; para fins didáticos e escolhemos representá-lo visualmente como um inteiro para simplificar nossa vida.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;exemploNode&lt;/em&gt;&lt;/strong&gt; é uma referência para um objeto do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; são referências para objetos do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt;. &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; aponta para o próximo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt;, que no nosso primeiro exemplo é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; enquanto &lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; aponta para o &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; anterior, que também é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Como cada nó tem referências para o anterior e para o próximo, chamamos essa lista de duplamente encadeada.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Como usar objetos do tipo Node para criar uma lista?&lt;/strong&gt; Em termos simplistas, ligando os nós. Veja:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
Node &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno(8, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;João&amp;#34;&lt;/span&gt;));
Node &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno(11, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Marielle&amp;#34;&lt;/span&gt;));
a.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b;
b.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a;
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;ligando.png&#34; alt=&#34;ligando&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Em primeiro lugar, criamos dois nós: &lt;strong&gt;&lt;em&gt;a&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;b&lt;/em&gt;&lt;/strong&gt;. Depois, fizemos &lt;code&gt;a.next&lt;/code&gt; apontar para o nó &lt;strong&gt;&lt;em&gt;b&lt;/em&gt;&lt;/strong&gt; (destaque em vermelho) e &lt;code&gt;b.prev&lt;/code&gt; apontar para &lt;strong&gt;&lt;em&gt;a&lt;/em&gt;&lt;/strong&gt; (destaque em verde). Com essas instruções encadeamos os objetos e temos agora uma lista com dois elementos e podemos, apenas a partir da referência do primeiro, acessar o segundo. Como? &lt;code&gt;a.next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note que os objetos foram criados em tempo de execução. Ou seja, a lista é criada dinamicamente sem que seja preciso definir o seu tamanho em tempo de compilação.&lt;/p&gt;

&lt;p&gt;Vamos analisar a lista abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;exemplo-lista.png&#34; alt=&#34;exempli-lista&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Não precisamos guardar todas as referências para os nós criados. Nesse caso apenas guardamos uma referência para o início da lista (&lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;) e vamos encadeando os nós para formar a lista. Guardamos também uma referência para o fim da lista (&lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;) para efetuar adicionar elementos no final da lista de maneira mais eficiente, como vamos discutir adiante.&lt;/p&gt;

&lt;p&gt;Uma &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; é nada mais do que um controlador dessas referências. Vamos ver como isso se dá em código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; LinkedList {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; head;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; tail;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; size;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LinkedList&lt;/span&gt;() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; isEmpty() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
    
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;organização-interna-atributos-construtor-e-isempty&#34;&gt;Organização interna: atributos, construtor e isEmpty&lt;/h2&gt;

&lt;p&gt;Primeiro, vamos às definições de atributos e do construtor. A classe &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; possui três atributos: uma referência para o início da lista, outra para o fim e um inteiro representando a quantidade de elementos na lista. No construtor &lt;em&gt;default&lt;/em&gt; esses atributos são iniciados com &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; e 0, respectivamente. Eu sei que não é preciso fazer isso porque os valores &lt;em&gt;default&lt;/em&gt; de Java para esses tipos são os mesmos que atribuí no construtor. Contudo, eu prefiro deixar isso explícito para que fique claro para quem está aprendendo e ainda não é fluente com as particularidades da linguagem.&lt;/p&gt;

&lt;h3 id=&#34;isempty&#34;&gt;isEmpty()&lt;/h3&gt;

&lt;p&gt;Este método verifica se a lista está vazia ou não. A verificação é feita comparando &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; com &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Se essa comparação for verdadeira, significa que não elemento algum na lista, pois &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; é a referência que controla o início e a partir da qual conseguimos acessar os outros elementos.&lt;/p&gt;

&lt;h2 id=&#34;operações-básicas-inserção-busca-e-remoção&#34;&gt;Operações básicas: inserção, busca e remoção.&lt;/h2&gt;

&lt;h3 id=&#34;inserção&#34;&gt;Inserção&lt;/h3&gt;

&lt;p&gt;Vamos abordar três tipos de inserção e uma lista encadeada:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;addLast(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addFirst(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add(int index, Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;addLast(Aluno aluno).&lt;/strong&gt; O primeiro método adiciona um elemento no final da lista. Como mantemos uma referência para o final da lista, a única preocupação aqui é saber se trata-se do primeiro elemento a ser adicionado. Caso seja esse o cenário, ambos, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, passam a apontar para o novo elemento. Caso contrário, precisamos fazer o novo elemento assumir o papel de &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;. Vamos ao código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; addLast(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(aluno);
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(isEmpty()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tail;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em um primeiro momento, criamos o nó que será adicionado. Depois, verificamos se a lista está vazia. Se estiver, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; apontam para o novo nó. Caso contrário, efetuamos 3 passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;adicionamos o novo nó à frente de &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; com a instrução
&lt;code&gt;this.tail.next = newNode&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fazemos com que o anterior do novo nó seja &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; com a instrução &lt;code&gt;newNode.prev = tail&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;o fim da lista passa a ser o novo nó &lt;code&gt;this.tail = newNode&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A adição de um elemento ao final da lista é realizada em tempo constante $O(1)$, pois envolve apenas a verificação de uma expressão booleana e algumas manipulações de referências.&lt;/p&gt;

&lt;p&gt;Note que apenas a primeira adição impacta na referência &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;. No entanto, todas as adições impactam a referência &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, pois todo novo elemento passa a ser considerado o fim da lista.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addFirst(Aluno aluno).&lt;/strong&gt; Este método adiciona elementos no início da lista. Nesse cenário também é preciso verificar se a lista está vazia. Caso seja esse o cenário, ambos, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, passam a apontar para o novo elemento. Caso contrário, precisamos fazer o novo elemento assumir o papel de &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; addFirst(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(aluno);
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    }
        
    size &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em um primeiro momento, criamos o nó que será adicionado. Depois, verificamos se a lista está vazia. Se estiver, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; apontam para o novo nó. Caso contrário, efetuamos 3 passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;adicionamos o novo nó atrás de &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; com a instrução &lt;code&gt;newNode.next = this.head&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fazemos com que o anterior de &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; aponte para o novo nó com a instrução &lt;code&gt;this.head.prev = newNode&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;o início da lista passa a ser o novo nó, ou seja, &lt;code&gt;this.head = newNode&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A adição de um elemento no início da lista é realizada em tempo constante $O(1)$, pois envolve apenas a verificação de uma expressão booleana e algumas manipulações de referências.&lt;/p&gt;

&lt;p&gt;Note que apenas a primeira adição impacta na referência &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;. No entanto, todas as adições impactam a referência &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;, pois todo novo elemento passa a ser considerado o início da lista.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;add(int index, Aluno aluno).&lt;/strong&gt; A semântica deste método é: encaixar um novo elemento no índice passado como parâmetro &amp;ldquo;afastando&amp;rdquo; os elementos à frente para a direita. O uso das aspas em afastando é para chamar atenção para o fato de que não precisamos executar a operação de &lt;strong&gt;&lt;em&gt;shift&lt;/em&gt;&lt;/strong&gt; $(O(n))$, mas apenas alterar as referências ($O(1)$).&lt;/p&gt;

&lt;p&gt;Vamos supor que o foi efetuada a chamada &lt;code&gt;lista.add(3, new Aluno(5, &amp;quot;Amarildo&amp;quot;))&lt;/code&gt;, em que queremos adicionar o objeto com matrícula 5 na posição 3 da lista. Veja a ilustração abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;insert.png&#34; alt=&#34;insert&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que o objeto com matrícula 5 vai assumir a posição 3 da lista. Para isso precisamos alterar as seguintes referências:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; do novo nó passa a ser o nó com valor 3;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; do novo nó passa a ser o nó com valor -9;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; do nó com valor -9 passa a ser o novo nó;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; do nó com valor 3 passa a ser o novo nó.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A essa altura você já deve ter percebido que listas encadeadas não são indexadas como as listas baseadas em arrays. Isto é, não há como acessar em tempo constante a n-ésima posição da lista, pois &lt;strong&gt;não&lt;/strong&gt; há como executar a instrução &lt;code&gt;listaEncadeada[index]&lt;/code&gt;. É preciso iterar até a posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; para adicionar o novo elemento. Lembrando que temos apenas as referências para o início e o fim da lista. Assim, precisamos partir do início da lista até uma posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; navegando através das referências &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Vamos analisar detalhadamente o código do método &lt;strong&gt;&lt;em&gt;add(int index, int value)&lt;/em&gt;&lt;/strong&gt; para discutirmos essas preocupações.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; add(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; size)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(aluno);
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addFirst&lt;/span&gt;(valor);
        
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(valor);
        
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
            
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
            
        size &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
            
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em primeiro lugar, verificamos se o índice passado como parâmetro é válido. Caso não seja, lançamos uma exceção.&lt;/p&gt;

&lt;p&gt;Caso &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; seja válido, criamos o novo nó e precisamos agora identificar 3 casos. Se o &lt;code&gt;index == 0&lt;/code&gt;, basta invocarmos o método &lt;strong&gt;&lt;em&gt;addFirst&lt;/em&gt;&lt;/strong&gt;, que já implementamos. Se &lt;code&gt;index == size&lt;/code&gt;,  basta invocarmos o método &lt;strong&gt;&lt;em&gt;addLast&lt;/em&gt;&lt;/strong&gt;, que já implementamos. Caso contrário, caímos no cenário da Figura acima. Então, precisamos iterar até a posição index - 1 e manipular as referências.&lt;/p&gt;

&lt;h3 id=&#34;como-iterar-em-uma-lista-encadeada&#34;&gt;Como iterar em uma lista encadeada?&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;           
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
    aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Inicialmente criamos uma referência auxiliar (&lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt;). Ela inicialmente aponta para &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e, a cada passo da iteração, vai sendo atribuída para o próximo da lista (&lt;code&gt;aux = aux.next&lt;/code&gt;). Não fazemos isso diretamente com a referência &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; porque perderíamos a referência para o início da lista. Por isso é preciso criar um auxiliar.&lt;/p&gt;

&lt;p&gt;Ao término desse laço, &lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt; estará apontando para o nó que será o anterior do novo nó. Vamos relembrar o cenário:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;insert-aux.png&#34; alt=&#34;insert-aux&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que &lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt; aponta para o nó com valor -9 após o loop. Apenas com uma referência para esse nó podemos então encaixar o novo nó com as instruções:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A adição de um elemento em uma posição arbitrária da &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; é $O(n)$, pois envolve iterar sobre a lista e, no pior caso, o índice passado como parâmetro é da ordem do número de elementos presentes.&lt;/p&gt;

&lt;h3 id=&#34;busca&#34;&gt;Busca&lt;/h3&gt;

&lt;p&gt;Vamos explorar 5 formas de acesso a elementos de uma LinkedList:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Aluno get(int index)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int indexOf(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean contains(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno getFirst()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno getLast()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Os três primeiros métodos compartilham de uma aspecto importante: todos envolvem iteração sobre a lista e, por isso, são $O(n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; size)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; indexOf(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()))
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; index;
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        index &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; contains(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; indexOf(aluno) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Aluno get(int index).&lt;/strong&gt; Este método recupera o aluno presente na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;. Em primeiro lugar verificamos se a posição é válida. Caso não seja lançamos uma exceção
&lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html&#34;&gt;IndexOutOfBounds&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Caso o índice seja válido, precisamos iterar do início da lista até o índice desejado. Usamos o comando &lt;strong&gt;&lt;em&gt;for&lt;/em&gt;&lt;/strong&gt; por se tratar de uma iteração definida. Ao final dessa iteração &lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt; aponta para o nó na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;. Assim, retornamos &lt;code&gt;aux.aluno&lt;/code&gt;, que é o objeto desejado.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;int indexOf(Aluno aluno).&lt;/strong&gt; Este método retorna o índice da primeira ocorrência do valor passado como parâmetro na lista. Novamente, iteramos sobre a lista, mas dessa vez usamos o comando &lt;strong&gt;&lt;em&gt;while&lt;/em&gt;&lt;/strong&gt;, pois a iteração é indefinida. Note que há duas condições de parada. Quando &lt;code&gt;aux == null&lt;/code&gt;, ou seja, percorremos toda a lista e não encontramos o aluno procurado e, por isso, retornamos -1. Ou quando encontramos o aluno procurado. Nesse último caso retornamos o valor da variável &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;, que é incrementada a cada passo da procura.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;boolean contains(Aluno aluno).&lt;/strong&gt; Este método apenas verifica se o aluno passado como parâmetro está presente na lista ou não. Para isso, reusamos o método &lt;strong&gt;&lt;em&gt;indexOf&lt;/em&gt;&lt;/strong&gt;. Se o resultado da execução for -1, o método &lt;strong&gt;&lt;em&gt;contains&lt;/em&gt;&lt;/strong&gt; retorna &lt;strong&gt;&lt;em&gt;false&lt;/em&gt;&lt;/strong&gt;. Caso contrário, retorna &lt;strong&gt;&lt;em&gt;true&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Os métodos &lt;strong&gt;&lt;em&gt;getFirst()&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;getLast()&lt;/em&gt;&lt;/strong&gt;, por sua vez, são $O(1)$, pois basta retornarmos os alunos armazenados nos nós cujas referências são &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, respectivamente.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; getFirst() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; getLast() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;remoção&#34;&gt;Remoção&lt;/h3&gt;

&lt;p&gt;Vamos explorar 4 formas remoção em uma &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Aluno removeFirst()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno removeLast()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno remove(int index)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean remove(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Os dois primeiros métodos envolvem apenas a manipulação de algumas referências e, por isso, são $O(1)$. Em ambos, precisamos checar se a lista está vazia ou se possui apenas um elemento.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; removeFirst() {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NoSuchElementException();
        
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
        
    size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; removeLast() {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NoSuchElementException();
        
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }           
    
    size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;

}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;removeFirst().&lt;/strong&gt; Esse método remove e retorna o primeiro elemento da lista. A primeira verificação que fazermos é se a lista está vazia. Se esse for o caso, lançamos a exceção &lt;strong&gt;&lt;em&gt;NoSuchElementException&lt;/em&gt;&lt;/strong&gt;. Depois, precisamos verificar se a lista contém apenas um elemento, pois isso requer que as referências &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; passem a apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Caso nenhuma dessas condições sejam verdadeiras (&lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt;), temos pelo menos dois elementos na lista. Nesse caso, basta fazer head apontar para o próximo elemento da lista (&lt;code&gt;head = head.next&lt;/code&gt;) e &lt;code&gt;head.prev&lt;/code&gt; apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeLast().&lt;/strong&gt; Esse método remove e retorna o último elemento da lista. A primeira verificação que fazermos é se a lista está vazia. Se esse for o caso, lançamos a exceção &lt;strong&gt;&lt;em&gt;NoSuchElementException&lt;/em&gt;&lt;/strong&gt;. Depois, precisamos verificar se a lista contém apenas um elemento, pois isso requer que as referências &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; passem a apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Caso nenhuma dessas condições sejam verdadeiras (&lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt;), temos pelo menos dois elementos na lista. Nesse caso, basta fazer &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; apontar para o seu anterior (&lt;code&gt;tail = tail.prev&lt;/code&gt;) e &lt;code&gt;tail.next&lt;/code&gt; apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Os outros dois métodos envolvem iterar sobre a lista, seja até o índice passado como parâmetro, seja procurando pelo elemento a ser removido. Por isso, ambos são $O(n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; size)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; removeFirst();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; removeLast();
    
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    
    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
                   size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;       
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; remove(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno)) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) removeFirst();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) removeLast();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
                aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
                size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        }
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;remove(int index) e remove(Aluno aluno).&lt;/strong&gt; Quando o elemento é encontrado, há 3 casos possíveis: o elemento está na primeira posição, na última ou entre outros dois. No primeiro caso, reusamos o método &lt;strong&gt;removeFirst()&lt;/strong&gt;. No segundo caso, reusamos o método &lt;strong&gt;removeLast()&lt;/strong&gt;. Para o terceiro caso, manipulamos as referências para ligar o anterior e o próximo: &lt;code&gt;aux.prev.next = aux.next&lt;/code&gt; e &lt;code&gt;aux.next.prev = aux.prev&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Por motivos de simplificação, a classe &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; que implementamos neste material manipula objetos do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; que armazenam objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;. Naturalmente, por ser de propósito geral, a implementação de &lt;a href=&#34;https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html&#34;&gt;LinkedList&lt;/a&gt; de Java permite o armazenamento e manipulação de qualquer objeto.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Tabelas Hash</title>
         <link>https://joaoarthurbm.github.io/eda/posts/hashtable/</link>
         <pubDate>Thu, 24 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/hashtable/</guid>
         <description>

&lt;p&gt;&lt;aside&gt;&lt;i class=&#34;fab fa-github fa-lg&#34; aria-hidden=&#34;true&#34;&gt; &lt;/i&gt; &lt;a href=&#34;https://github.com/joaoarthurbm/eda-ufcg/tree/master/java/src/tabelahash&#34;&gt; &lt;font color=&#34;#1980e6&#34;&gt; &lt;b&gt;Código utilizado neste material&lt;/b&gt;&lt;/font&gt;&lt;/a&gt;&lt;/aside&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Quando tratamos de estrutura de dados estamos sempre interessados na eficiência de operações fundamentais de coleções, como busca, inserção e remoção. Nesse sentido, o array, embora seja uma estrutura elementar, é um excelente escolha para diversos cenários, pois nos fornece acesso, inserção e remoção em tempo $O(1)$. Isto é, se soubermos o índice em que um elemento está, o tempo de acesso a esse elemento é extremamente eficiente. O mesmo ocorre para adicionar um elemento em uma posição arbitrária, pois o custo dessa operação é dado pela operação primitiva de atribuição (ex: &lt;code&gt;array[4] = &amp;quot;computacao@ufcg&amp;quot;&lt;/code&gt;). Por fim, a remoção pode também ser efetuada em $O(1)$ atribuindo o valor da posição para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; (ex: &lt;code&gt;array[8] = null&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Vamos analisar o cenário em que desejamos armazenar objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt; que representam os alunos de Computação @ UFCG. Para fins de simplificação, o objeto do tipo aluno possui dois atributos: matrícula e nome.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; Aluno {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; matricula;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; nome;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; getMatricula() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;matricula&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; getNome() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;nome&lt;/span&gt;;
    }
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vamos também assumir que a matrícula identifica unicamente um aluno do curso e que é um inteiro no domínio [0&amp;hellip;1999]&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Nesse material chamamos de chaves os atributos dessa natureza. Dentro desse cenário, um array é uma estrutura muito adequada, porque podemos armazenar o aluno na posição do array cujo valor é o mesmo de sua matrícula. Não somente a inserção, mas a busca e a remoção desse objeto pode ser realizada em tempo $O(1)$, pois &lt;strong&gt;há uma correspondência direta entre o identificador único do aluno (a chave) e o índice em que ele se encontra no array&lt;/strong&gt;. Veja:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String[] &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;) {
    Aluno[] &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno[2000];

    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;joao&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno(21, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;João Arthur&amp;#34;&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// inserindo em tempo constante
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    alunos[joao.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; joao;

    &lt;span style=&#34;color:#75715e&#34;&gt;// buscando em tempo constante
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos[joao.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        ...

    &lt;span style=&#34;color:#75715e&#34;&gt;// removendo em tempo constante
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    alunos[joao.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note que, como há uma correspondência direta entre a matrícula e o índice em que o elemento está, as operações são muito eficientes.&lt;/p&gt;

&lt;p&gt;Chamamos de &lt;strong&gt;Tabela de Acesso Direto&lt;/strong&gt; o array que é usado dessa maneira, isto é, com os valores sendo mapeados de forma direta para os índices do array. Foi assim que usamos o array para ordenar em tempo linear com o &lt;a href=&#34;https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/&#34;&gt;Counting Sort&lt;/a&gt;, lembra?&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;os-problemas&#34;&gt;Os Problemas&lt;/h1&gt;

&lt;p&gt;Vamos tentar ser um pouco mais realistas no nosso exemplo. Todos sabemos que as matrículas em Computação @ UFCG não variam de 0 a 1999, certo? Nossas matrículas são números inteiros de 9 dígitos (ex: 203198353). Portanto, teoricamente, [000000000, 999999999] é o intervalo de matrículas válidas em Computação @ UFCG. Normalmente, em outros domínios isso também é verdade. Os elementos que nos identificam unicamente são tipicamente números com vários dígitos, por exemplo, CPF, cartão de crédito, identidade etc. Assim, se quiséssemos armazenar os alunos utilizando a matrícula como índices teríamos que criar um array com $10^9$ posições.&lt;/p&gt;

&lt;p&gt;Mesmo isso sendo possível, uma grande parte desse array não seria utilizada, pois o padrão usado para criar as matrículas baseia-se no ano, período de entrada e posição de entrada no vestibular e, por isso, exclui uma grande quantidade de números no intervalo [000000000, 999999999]. Além disso, ao longo de toda a história, Computação @ UFCG teve aproximadamente 2000 matrículas, o que significa que o número de matrículas efetivamente usadas é bem menor do que o número de matrículas possíveis. Isto é, teríamos que criar um array de $10^9$ posições para usar aproximadamente apenas os primeiros 2000 índices.&lt;/p&gt;

&lt;p&gt;Importante destacar também que para outros cenários, como por exemplo o CPF que possui 11 dígitos, não somente o desperdício de memória é um problema, mas não há como criar arrays de $10^11$ posições em várias linguagens de programação.&lt;/p&gt;

&lt;p&gt;Em resumo, é inviável utilizar mapeamento direto (tabela de acesso direto) para chaves cujo valor é muito alto. Além disso, não é eficiente do ponto de vista de memória utilizar mapeamento direto em domínios cujo conjunto de chaves efetivamente utilizado é bem menor do que o conjunto de chaves possível.&lt;/p&gt;

&lt;p&gt;Por último, mas não menos importante, nem sempre a chave é representada como um inteiro. Por exemplo, para fins de identificação, a Polícia Federal utiliza uma chave com 3 caracteres e 5 números inteiros (ex: CVP3018). Não é difícil notar que não há índice CVP3018 em um array, certo?&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-solução-tabela-hash&#34;&gt;A Solução: Tabela Hash&lt;/h1&gt;

&lt;p&gt;Vamos deixar claro: queremos mapear valores inteiros grandes (ex: 87562874658) para índices de um array. Veja a figura abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;exemplo1.png&#34; alt=&#34;tabela1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para isso, vamos utilizar uma função matemática. A ideia é criar essa função de mapeamento &lt;strong&gt;&lt;em&gt;(hash(chave)&lt;/em&gt;&lt;/strong&gt;) entre o valor da chave e um inteiro (hash) que seja um índice válido no array. A essa função damos o nome de função hash. Usando essa função conseguimos mapear as chaves para os índices do array e conseguimos então armazenar nossos objetos. Os objetos, nesse caso, são chamados de valores. Assim, na tabela armazenamos os pares &lt;strong&gt;&lt;em&gt;&lt;chave, valor&gt;&lt;/em&gt;&lt;/strong&gt;. Como a chave é tipicamente um atributo do objeto, essa redundância é bem comum. Isto é, armazenamos a chave e o objeto, que por sua vez contém a chave.&lt;/p&gt;

&lt;p&gt;Note que a função de hash precisa ter algumas características bem importantes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A função &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt; deve ser determinística. Para uma determinada chave a função sempre retorna o mesmo valor dehash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Por ser utilizada como uma função de indexação, a função de hash deve sempre retornar um valor de hash dentro dos limites da tabela $[0, N-1]$, onde $N$ é o tamanho da tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uniforme. Todos os índices do array devem ter aproximadamente a mesma chance de serem mapeados pela função dehash. Essa característica é importante para distribuir os elementos uniformemente pela tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A função de hash deve ser executada em tempo constante $O(1)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;como&#34;&gt;Como?&lt;/h2&gt;

&lt;p&gt;A gente já fez isso nesse documento. Conceitualmente, na tabela de acesso direto apresentada na contextualização temos a seguinte função de hash:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; hash(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; chave;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ou seja, o hash de uma chave é o valor dela própria. Essa é uma função de hash bem simples, mas adequada para diversos contextos. Contudo, isso nos causou problemas para para grandes valores chave e para cenários em que o número de chaves efetivamente usado for bem menor que o número de chaves possível, lembra?&lt;/p&gt;

&lt;p&gt;Uma alternativa para uma função de hash seria utilizar a operação matemática módulo. Vejamos:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; hash(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; chave &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; tabela.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Veja que essa é a solução que foi utilizada na Figura acima. Pois, $807365841 % 10 = 1$, $111983749 % 10 = 9$ e $665422653 % 10 = 3$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Por que módulo?&lt;/strong&gt; Primeiro porque sempre vai gerar um inteiro dentro do intervalo de índices válidos do array. Segundo porque para uma mesma chave, a função sempre retorna o mesmo hash.&lt;/p&gt;

&lt;p&gt;Note que, se a função de hash for executada em tempo constante, o que é o caso da função $chave % tabela.length$, temos que as funções básicas da tabela hash são, em princípio, também executadas em tempo constante.&lt;/p&gt;

&lt;p&gt;Vamos analisar o código abaixo que apresenta algumas operações básicas da classe &lt;strong&gt;&lt;em&gt;TabelaHash&lt;/em&gt;&lt;/strong&gt;. Por motivos de simplificação, a classe que usaremos aqui implementa uma tabela hash para manipular objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;. Naturalmente, por ser de propósito geral, as implementações de Java de uma Tabela Hash (HashMap e HashTable) permitem o armazenamento e manipulação de qualquer objeto.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; HashTable {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt;[] tabela;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HashTable&lt;/span&gt;() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno[20];
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; hash(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; chave &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    }  

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; put(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;valor&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; valor;
    }  

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
        Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash(chave)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
    }  

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Parece tudo resolvido, não é? Mas&amp;hellip;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; &lt;b&gt;E se duas chaves distintas forem mapeadas para a mesma posição na tabela? &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Por exemplo, vimos que o objeto $(807365841, &amp;ldquo;Chico Buarque&amp;rdquo;)$ foi mapeado para o índice 1 da tabela porque $807365841 % 10$ é igual a 1. Suponha que agora temos que armazenar o objeto $(478243081, &amp;ldquo;Gilberto Gil&amp;rdquo;)$. Teremos um problema aqui, pois o hash desse objeto também tem valor 1, cujo índice já está ocupado. Na verdade, toda chave que terminar com o dígito 1 será mapeada para a posição 1 na tabela. Esse problema se chama &lt;strong&gt;colisão&lt;/strong&gt;. Quando estamos diante desse problema, temos três caminhos a seguir:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Aplicar a técnica do avestruz, isto é, enfiar a cabeça na terra e fingir que o problema não existe;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Melhorar nossa função de hash para que a mesma não mapeie diferentes chaves para a mesma posição;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lidar com a colisão.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O caminho de número 1 está fora de cogitação porque não queremos que uma estrutura de dados sobrescreva inadvertidamente um elemento que colocamos nela anteriormente.&lt;/p&gt;

&lt;p&gt;O caminho número 2 é válido e discutiremos mais adiante algumas decisões de projeto de funções de hash que reduzem o número de colisões. Contudo, a menos que a função seja perfeita, o que é muito raro, veremos também que, mesmo tomando essas decisões, colisões são inevitáveis.&lt;/p&gt;

&lt;p&gt;Então, nos sobra, por enquanto, o caminho 3. Vamos assumir como verdade que, mesmo se a função de hash for muito boa, é impossível evitar colisões. Portanto, haverá colisões e teremos que tratá-las de forma eficiente.&lt;/p&gt;

&lt;h2 id=&#34;resolução-de-colisões&#34;&gt;Resolução de Colisões&lt;/h2&gt;

&lt;p&gt;Há duas grandes estratégias lidar com esse problema: resolução de colisões por encadeamento e resolução de colisões por endereçamento aberto.&lt;/p&gt;

&lt;h3 id=&#34;resolução-de-colisões-por-encadeamento&#34;&gt;Resolução de colisões por encadeamento.&lt;/h3&gt;

&lt;p&gt;Por trás desse nome complicado há uma ideia bem simples. Ao invés de armazenarmos um objeto em uma posição da tabela, passamos a armazenar uma lista de objetos. Essa lista será composta de todos os objetos cujos hashes são iguais. Veja na figura abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;encadeamento.png&#34; alt=&#34;encadeamento&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Os objetos de mesmo hash foram encadeados em uma lista. Esse foi o caso de $(807365841, &amp;ldquo;Chico Buarque&amp;rdquo;)$ e $(478243081, &amp;ldquo;Gilberto Gil&amp;rdquo;)$, que estão em uma lista no índice 1 da tabela, pois os hashes de suas respectivas chaves são o mesmo: 1. O mesmo acontece com $(665422653, &amp;ldquo;Marielle&amp;rdquo;)$ e $(960424613, &amp;ldquo;Amarildo&amp;rdquo;)$, que foram encadeados em uma lista no índice 3.&lt;/p&gt;

&lt;p&gt;Importante aqui destacar que esses objetos não possuem a mesma chave, mas sim o mesmo hash. &lt;strong&gt;Não há elementos com a mesma chave em uma tabela hash&lt;/strong&gt;. Eu vou repetir em destaque porque esse é um erro recorrente:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; &lt;b&gt;Não há elementos com a mesma chave em uma tabela hash.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Se for realizada a tentativa de adição de um elemento cuja chave já está presente na tabela, o valor (objeto armazenado) deve ser atualizado. Também é importante destacar que devemos guardar a chave junto com o objeto na lista, pois só assim saberemos diferenciar os objetos de mesmo hash.&lt;/p&gt;

&lt;p&gt;Uma vez que estamos utilizando listas na tabela, o código das operações básicas deve ser modificado, concorda? Vamos primeiro analisar o método &lt;strong&gt;&lt;em&gt;get&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
    ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; alunos) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aluno.&lt;span style=&#34;color:#a6e22e&#34;&gt;matricula&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Na segunda linha do método recuperamos a lista &lt;strong&gt;&lt;em&gt;alunos&lt;/em&gt;&lt;/strong&gt; presente no índice &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt;. Se essa lista for &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;, significa que não há elemento naquela posição da tabela e, por isso, retornamos &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; (linhas 3 e 4).&lt;/p&gt;

&lt;p&gt;Se a lista não for &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;, precisamos iterar sobre a mesma comparando as chaves (matrículas). Caso haja um objeto aluno com uma matrícula igual a passada como parâmetro, retornamos esse objeto.&lt;/p&gt;

&lt;p&gt;Se ao fim da iteração não encontrarmos nenhum objeto na lista cuja matrícula seja igual a chave passada como parâmetro, retornamos &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Vamos agora analisar o método put.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; put(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;valor&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
    ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        alunos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
        alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(valor);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; alunos;

    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;(); i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(i).&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave) {
                alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(i, valor);
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
            }
        }
    
        alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(valor);
    }    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No início, recuperamos a lista que está no índice &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt;. Se não existir uma lista nesse índice (&lt;code&gt;alunos == null&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;criamos essa lista;&lt;/li&gt;
&lt;li&gt;adicionamos o valor nela;&lt;/li&gt;
&lt;li&gt;adicionamos a lista na tabela.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Se existir uma lista nesse índice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;iteramos sobre a lista para ver se há na mesma um elemento com a mesma chave;

&lt;ul&gt;
&lt;li&gt;se houver, atualiza-se o valor (&lt;code&gt;alunos.set(i, valor)&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;se não houver, adiciona-se o novo elemento no final da lista.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por fim, vamos analisar o método remove.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
    ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    
    Iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;iterator&lt;/span&gt;();
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;atual&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (it.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasNext&lt;/span&gt;()) {
        atual &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; it.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (atual.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave) {
            it.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; atual;
        }
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; atual;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A ideia consiste em: i) recuperar a lista presente no índice &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt; que, a princípio, contém o elemento a ser removido e ii) iterar sobre a lista comparando a chave dos elementos (matrícula) com a chave passada como parâmetro. Caso o elemento seja encontrado, o removemos da lista.&lt;/p&gt;

&lt;h4 id=&#34;discussão-sobre-o-tempo-de-execução&#34;&gt;Discussão sobre o tempo de execução&lt;/h4&gt;

&lt;p&gt;Como foi possível perceber, a implementação dessas operações básicas inclui agora a iteração sobre as listas presentes na tabela. Isso significa que haverá um impacto na eficiência desses algoritmos, concorda? Na tabela de acesso direto as operações eram executadas em tempo constante $O(1)$. Contudo, como as listas podem crescer substancialmente e os algoritmos envolvem iteração sobre as mesmas, não temos mais esse cenário. Para exemplificar, vamos pensar no pior caso possível. Suponha que queremos adicionar os seguintes alunos na tabela:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(736435217, &amp;ldquo;Lívia&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(879995247, &amp;ldquo;Will&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(524109227, &amp;ldquo;Clara&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(736435217, &amp;ldquo;Talita&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nesse caso, como nossa função de hash mapeia todos os elementos para o índice 7, teríamos a seguinte configuração:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;colisao.png&#34; alt=&#34;colisao.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que a busca por um elemento presente na tabela não seria mais realizada em tempo constante, pois envolve a iteração na lista que contém todos os elementos. Portanto, no pior caso, as operações teriam custo de execução $O(n)$, o que queremos evitar ao máximo.&lt;/p&gt;

&lt;p&gt;Naturalmente, não queremos que o pior caso seja frequente e, por isso, escolhemos funções de hash que &amp;ldquo;espalham&amp;rdquo; os elementos pela tabela para que as listas não possuam muitos elementos. Portanto, o desempenho médio das operações na tabela hash depende do tamanho médio das listas armazenadas. Lembra da propriedade de uma função de hash que estabelece que todos os índices do array devem ter aproximadamente a mesma chance de serem mapeados pela função de hash. Essa característica é importante para distribuir os elementos uniformemente pela tabela e faz com que as listas tenham tamanho médio semelhante. Então, para uma tabela de tamanho $m$ que armazena nelementos, esperamos que o tamanho médio das listas seja $\alpha = n/m$. A esta medida damos o nome de fator de carga.&lt;/p&gt;

&lt;p&gt;A análise depende então do tempo de execução da função de hash e do tamanho médio das listas. Como vimos, escolhemos funções de hash que executam em $O(1)$.Então, o tempo de execução das operações básicas pode ser dado por:&lt;/p&gt;

&lt;p&gt;$T(n) = 1 + \alpha$, onde $\alpha$ é o tamanho médio das listas armazenadas na tabela.&lt;/p&gt;

&lt;h3 id=&#34;resolução-de-colisões-por-endereçamento-aberto&#34;&gt;Resolução de colisões por endereçamento aberto.&lt;/h3&gt;

&lt;p&gt;Essa estratégia não utiliza listas para lidar com colisões. A ideia é procurar um outro índice livre da tabela para armazenar o elemento quando houver colisão. Há diversas estratégias para procurar esse índice. Vamos apresentar a mais simples delas: procurar o próximo. Veja a implementação do método &lt;strong&gt;&lt;em&gt;put(chave, Aluno)&lt;/em&gt;&lt;/strong&gt; quando adotamos essa estratégia:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; put(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;valor&lt;/span&gt;) {       
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sondagem&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (sondagem &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; tabela.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;) {
        
        hash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (hash(chave) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sondagem) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; tabela.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (tabela[hash] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
            tabela[hash].&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
            tabela[hash].&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(APAGADO)) {
                tabela[hash] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; valor;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
            
        sondagem &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TabelaCheiaException();

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O importante aqui é entender o uso da variável sondagem. Ela inicia com valor zero e é utilizada como fator para calcular o hash. Caso haja colisão, essa variável é incrementada e a próxima posição na tabela será analisada. Isso é feito até que uma das condições abaixo seja satisfeita:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;encontrar um índice livre. Um índice está livre quando seu conteúdo é null ou quando seu conteúdo é um objeto APAGADO (explicação mais adiante);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;encontrar um valor cuja chave é igual a passada como parâmetro. Nesse caso, atualiza-se o valor;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;não encontrar posição livre na tabela (&lt;code&gt;sondagem == tabela.length - 1&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note que não há listas e, portanto, nenhum elemento é armazenado fora da tabela. Isso significa que o fator de carga ($\alpha$) nunca pode ser maior do que 1. Por isso lançamos a exceção ao final da execução do método caso não haja posição livre na tabela. Tomamos essa decisão para fins didáticos. Na prática, quando a tabela atinge um certo nível de ocupação, executamos o método resize, isto é, cria-se uma outra tabela maior e transfere-se os elementos da tabela anterior para a nova aplicando a nova função de hash (ver &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;rehash&lt;/em&gt;&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;Para entender bem a ideia de sondagem, vamos analisar a adição dos seguintes objetos na tabela:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(736435217, &amp;ldquo;Lívia&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(879995247, &amp;ldquo;Will&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(524109227, &amp;ldquo;Clara&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(736435217, &amp;ldquo;Talita&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;colisao-prob.png&#34; alt=&#34;colisao-prob&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Na primeira adição, o objeto $(736435217, &amp;ldquo;Lívia&amp;rdquo;)$ ocupa a posição 7 na tabela, pois esse índice é calculado da seguinte maneira:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((736435217 % 10) + 0) % 10;&lt;/p&gt;

&lt;p&gt;Ou seja, o hash assume valor 7. Explicando: como o valor inicial da sondagem é zero, temos que $7 + 0 = 7$. Calculamos então o resto da divisão desse valor pelo tamanho da tabela $7 % 10 = 7$. Portanto, o índice avaliado é o índice 7. Por não haver nenhum elemento nesse índice, o objeto é adicionado.&lt;/p&gt;

&lt;p&gt;Na segunda adição, isto é, na adição do objeto $(879995247, &amp;ldquo;Will&amp;rdquo;)$, o objeto ocupará a posição 8 da tabela. Isso acontece porque o cálculo&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((879995247 % 10) + 0) % 10;&lt;/p&gt;
            

&lt;p&gt;também tem como resultado o índice 7. Então temos uma colisão nesse índice. O algoritmo então incrementa o valor da sondagem para 1. Assim, temos um novo cálculo,&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((879995247 % 10) + 1) % 10; &lt;/p&gt;

&lt;p&gt;que resulta em 8. Como 8 é um índice não ocupado, adicionamos o valor nesse índice.&lt;/p&gt;

&lt;p&gt;Na terceira adição, temos duas colisões: usando $sondagem = 0$ e $sondagem = 1$. Somente quando usamos $sondagem = 2$ é que encontramos um índice livre.&lt;/p&gt;

&lt;p&gt;Na quarta adição, temos três colisões: usando $sondagem = 0$, $sondagem = 1$ e $sondagem = 2$. Somente quando usamos $sondagem = 3$ é que encontramos um índice livre. Note que esse objeto será adicionado no índice 0 da tabela, pois o resultado da expressão abaixo é 0.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((736435217 % 10) + 3) % 10;&lt;/p&gt;

&lt;p&gt;Como estamos incrementando a sondagem sempre em uma unidade para avaliar o próximo índice da tabela, chamamos essa técnica de sondagem linear. Outras estratégias de sondagem também são utilizadas, como por exemplo, a sondagem quadrática em que, ao invés de incrementar a sondagem em uma unidade, usamos uma função quadrática para esse incremento.&lt;/p&gt;

&lt;p&gt;O método &lt;strong&gt;&lt;em&gt;get&lt;/em&gt;&lt;/strong&gt; e o método &lt;strong&gt;&lt;em&gt;remove&lt;/em&gt;&lt;/strong&gt; também precisam usar a sondagem, pois as colisões também afetam a busca e a remoção. Em particular, é preciso ter um cuidado a mais com o método remove. Quando vamos remover um elemento de uma tabela, não atribuímos &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; no índice como fazíamos até então.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;b&gt;Por que?&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Porque na adição e na busca a sondagem precisa diferenciar se o conteúdo do índice é de fato &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou se ele já foi ocupado antes por algum elemento que foi apagado. Por isso, quando apagamos um elemento, ao invés da instrução &lt;code&gt;tabela[hash] = null&lt;/code&gt;, incluímos uma guarda naquele índice para estabelecer que ele está vago para uma nova adição. Isso é feito incluindo um objeto &amp;ldquo;flag&amp;rdquo;. No nosso caso, escolhemos um objeto do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt; com matrícula &lt;strong&gt;&lt;em&gt;Integer.MIN_VALUE&lt;/em&gt;&lt;/strong&gt; e nome &amp;ldquo;APAGADO&amp;rdquo;. Veja a implementação dessa estratégia no &lt;a href=&#34;https://github.com/joaoarthurbm/eda-ufcg/tree/master/java/src/tabelahash&#34;&gt;código disponível no github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Assim, na adição, se o conteúdo do índice for &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou for APAGADO, o índice está livre para ser preenchido.&lt;/p&gt;

&lt;p&gt;Na busca, se o conteúdo do índice for APAGADO a sondagem deve continuar a procura, ao invés de parar. Por isso precisamos dessa flag.&lt;/p&gt;

&lt;p&gt;Em resumo, ao apagar um objeto, ao invés de atribuir &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ao índice, incluímos uma objeto flag APAGADO para que os algoritmos de sondagem possam saber quando de fato parar.&lt;/p&gt;

&lt;h4 id=&#34;discussão-sobre-o-tempo-de-execução-1&#34;&gt;Discussão sobre o tempo de execução&lt;/h4&gt;

&lt;p&gt;Novamente, a implementação das operações básicas incluem iteração. Na resolução por encadeamento essa iteração era realizada nas listas. Na resolução por endereçamento aberto essa iteração é dentro da própria tabela, seguindo a sondagem estabelecida. No caso em que todas as chaves possuem o mesmo hash, o tempo de execução será $O(n)$, onde $n$ é a quantidade de elementos na tabela. Naturalmente, esse é o pior caso e é gerado porque nossa função de hash não lida muito bem com chaves que terminam com o mesmo dígito. Portanto, chegou a hora de discutirmos melhores estratégias para cálculo do hash.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;funções-de-hash&#34;&gt;Funções de Hash&lt;/h1&gt;

&lt;p&gt;A função de hash que estamos utilizando até então sempre usava apenas o último dígito do número como hash, uma vez que estávamos tratando de uma tabela de tamanho 10. Você consegue enxergar isso? O resto da divisão de qualquer número por 10 é o último dígito desse número.&lt;/p&gt;

&lt;p&gt;Essa não é uma função de hash boa. Tivemos a oportunidade de ver isso com detalhes para os casos em que vários elementos de chaves diferentes foram mapeados para a mesma posição porque o último dígito de cada uma dessas chaves era igual ao último dígito das demais chaves.&lt;/p&gt;

&lt;p&gt;E se usarmos um número primo na divisão? Uma boa estratégia é escolher um número primo para ser o tamanho da tabela. Vamos ver como essa pode ser uma boa estratégia na prática.&lt;/p&gt;

&lt;p&gt;Suponha o seguinte conjunto de chaves $K = {200, 205, 210, 215, 220, 225&amp;hellip;595}$. Se escolhermos uma tabela de tamanho 100, teríamos a função de hash definida por $hash(chave) = chave % 100$. Para esse conjunto de chaves apenas os índices terminados em 0 e 5 seriam mapeados pela função de hash. Isto é, as posições 0, 5, 10, 15, 20, 15 e assim por diante. Em cada uma dessas posições teríamos 4 colisões. Por exemplo, na posição 0, teríamos os objetos de chaves 200, 300, 400 e 500 mapeados. Na posição 5, teríamos os objetos de chaves 205, 305, 405 e 505 mapeados. Na posição 10, teríamos os objetos 210, 310, 410 e 510 mapeados, e assim por diante. Além do desperdício de memória, temos um número elevado de colisões. 60, para ser exato.&lt;/p&gt;

&lt;p&gt;Agora vamos escolher uma tabela de tamanho 101, um número primo. Nossa função de hash passa a ser definida por $hash(chave) = chave % 101$. Para o mesmo conjunto de chaves &lt;strong&gt;não teríamos colisão alguma!&lt;/strong&gt; Basta fazer a operação em cada chave para verificar que todas as chaves desse conjunto seriam mapeadas para índices diferentes na tabela.&lt;/p&gt;

&lt;p&gt;O &lt;strong&gt;método da multiplicação&lt;/strong&gt; é uma outra estratégia para desenvolver uma boa função de hash. Ao invés de dividirmos a chave por um número primo, como fazemos no método da divisão, aplicamos as seguintes operações:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;multiplicar a chave por uma constante &amp;ndash; um número decimal;&lt;/li&gt;
&lt;li&gt;extrair a parte fracioária do resultado anterior;&lt;/li&gt;
&lt;li&gt;multiplicar o número anterior pelo tamanho da tabela;&lt;/li&gt;
&lt;li&gt;extrair a parte inteira do resultado anterior.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A função de hash é definida, então, por:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash(chave) = int(((chave * A) % 1) * m),&lt;/p&gt;

&lt;p&gt;onde $A$ é um número constante decimal e $m$ é o tamanho da tabela.&lt;/p&gt;

&lt;p&gt;Vamos analisar exemplo concreto. Suponha que a chave seja 100, o número decimal escolhido seja $A = 0.63274838$ e o tamanho da tabela seja 20.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;100*0.63274838 = 63.274838&lt;/li&gt;
&lt;li&gt;63.274838 % 1 = 0.274838&lt;/li&gt;
&lt;li&gt;0.274838 * 20 = 5.49676&lt;/li&gt;
&lt;li&gt;int(5.49676) = 5&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Teríamos então que hash(100) = 5.&lt;/p&gt;

&lt;h2 id=&#34;rehash-e-resize&#34;&gt;Rehash e Resize&lt;/h2&gt;

&lt;p&gt;O método da divisão por um número primo e o método da multiplicação são estratégias eficazes para reduzir a probabilidade de colisão. Esses dois métodos aliados à resolução por encadeamento ou por endereçamento aberto tornam a tabela hash uma estrutura de dados eficiente, pois permitem que as operações básicas de inserção, remoção e busca sejam executadas em tempo constante. Todavia, mesmo com essas estratégias, se quisermos armazenar na tabela um número de objetos maior do a sua capacidade teremos problemas em ambas. Na resolução por encadeamento teremos listas cada vez maiores e, por consequência, degradação na eficiência das operações. Na resolução por endereçamento aberto não é possível um fator de carga maior do que 1, isto é, não é possível armazenar na tabela um número de objetos maior do que o tamanho da mesma. Portanto, temos que aumentar o tamanho da tabela (&lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt;) quando o número de elementos a serem armazenados se aproxima do seu tamanho. Concretamente, quando a expressão booleana abaixo for avaliada como &lt;strong&gt;&lt;em&gt;true&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fatorDeCarga&lt;/span&gt;) {
    resize()
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Como sabemos, a tabela é um array e, por isso, não é possível aumentar o seu tamanho inicial. O que fazemos é criar uma nova tabela maior do que a original e realocar os elementos nessa nova tabela. Aqui é importante destacar que os elementos não são alocados nas posições originais, pois, ao criar uma nova tabela, teremos também uma nova função de hash, dado que o tamanho da tabela mudou e nossa função baseia-se nesse tamanho para o cálculo do hash (&lt;strong&gt;&lt;em&gt;rehash&lt;/em&gt;&lt;/strong&gt;). Nesse caso, temos que iterar sobre todos os elementos da tabela original invocando o método put em todos esses elementos. &lt;a href=&#34;https://github.com/joaoarthurbm/eda-ufcg/tree/master/java/src/tabelahash&#34;&gt;O código disponibilizado no github&lt;/a&gt; implementa essa rotina.&lt;/p&gt;

&lt;p&gt;Como vamos iterar sobre os elementos da tabela, esse é um bom momento para que você conheça os métodos: &lt;strong&gt;&lt;em&gt;keySet()&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;values()&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;entrySet()&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;keySet()&lt;/em&gt;&lt;/strong&gt; retorna o conjunto de chaves presentes na tabela. No nosso caso seria o conjunto de todas as matrículas armazenadas na tabela.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;value()&lt;/em&gt;&lt;/strong&gt; retorna o conjunto de valores presentes na tabela. No nosso caso seria o conjunto de todos os alunos armazenados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;entrySet()&lt;/em&gt;&lt;/strong&gt; retorna o conjunto de itens (chave, valor) presentes na tabela. No nosso caso seria o conjunto de pares Matrícula, Aluno armazenados na tabela.&lt;/p&gt;

&lt;p&gt;Note que independente do método utilizado é importante destacar que não há a noção de ordenação em uma tabela hash, isto é, o elemento no índice 3 da tabela não necessariamente foi adicionado antes do elemento no índice 4.&lt;/p&gt;

&lt;h3 id=&#34;quando-executar-o-resize&#34;&gt;Quando executar o resize?&lt;/h3&gt;

&lt;p&gt;Uma tabela hash que resolve colisões por endereçamento aberto possui um fator de carga menor do que 1. Vamos relembrar: fator de carga é a ocupação máxima permitida em uma tabela. Se a tabela possui $m$ posições, podemos, por exemplo, estabelecer que a ocupação máxima é 50% (0.5). Assim, quando atingirmos esse limite, o resize é executado. Então, surge a pergunta:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;Qual fator de carga máximo utilizar? Isto é, quando executar o resize?&lt;/p&gt;

&lt;p&gt;Se utilizarmos um fator de carga muito pequeno, faríamos o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; com muita frequência, o que queremos evitar por se tratar de uma rotina $O(n)$.Contudo, se o fator de carga for alto, digamos 0.95 o número de colisões aumenta bastante e degrada a eficiência das operações.
A biblioteca padrão de Java utiliza 0.75 como fator de carga. Esse número foi estabelecido porque, através de experimentos, notou-se que a partir desse fator de carga as colisões passam a ser muito mais frequentes e o desempenho das operações piora substancialmente.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;resumo&#34;&gt;Resumo&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Chave identifica unicamente um objeto. Tipicamente é um atributo dele. Por exemplo, matrícula para aluno, CPF para pessoa, CNPJ para empresa, número do cartão de crédito para cliente etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uma tabela de acesso direto é um array em que os objetos são indexados pelas suas respectivas chaves. Por isso ela só é adequada para chaves inteiras e com valores pequenos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hash é um valor inteiro gerado a partir da chave. Usamos esse hash quando temos que lidar com chaves inteiras de valor muito grande ou que não são números naturais.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tabela hash é um nome sofisticado para um array cuja indexação é feita através de uma função.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tabela hash é uma estrutura de dados eficiente no que diz respeito à inserção, remoção e busca de elementos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O método da divisão por um número primo e o método da multiplicação são boas estratégias para implementar funções de hash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uma função de hash deve ser determinística, executada em tempo constante e uniforme.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Não há elementos com a mesma chave em uma tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Diferentes chaves podem ter o mesmo hash. Isso se chama colisão.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exceto em algumas raras exceções, colisões vão existir. A forma como lidamos com elas é encadeando objetos em uma lista ou procurando outras posições livres na tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A biblioteca padrão de Java utiliza endereçamento aberto para lidar com colisões.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quando o número de objetos a serem armazenados cresce a ponto de degradar a eficiência das operações básicas, precisamos criar uma nova tabela e realocar todos os elementos da tabela original nessa nova tabela. Isso se chama resize. Quando fazemos isso, aplicamos a nova função de hash. Isso se chama rehash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A biblioteca padrão de Java usa 0.75 como fator de carga para decidir quando fazer o resize. Isso significa que quando a tabela atinge 75% de ocupação o resize é executado.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;A implementação utilizada neste material foi baseada em chaves inteiras e valores do tipo Aluno. Essa foi uma decisão didática. Uma Tabela Hash é uma estrutura de dados de propósito geral e deve ser capaz de armazenar objetos de qualquer tipo.&lt;/p&gt;

&lt;p&gt;Utilizei neste capítulo chaves baseadas em números inteiros também para fins didáticos. Chaves podem ser de qualquer tipo. O importante é que elas identifiquem unicamente um objeto.&lt;/p&gt;

&lt;p&gt;Este é um material carece de algumas discussões importantes que conduzo em sala de aula. Em particular, acho relevante discutir: Por que um número primo é uma boa escolha no método da divisão? Por que um número decimal com muitos dígitos depois da vírgula é uma boa escolha no método da multiplicação? Quais são os problemas relacionados à sondagem linear? Quais são as outras formas de sondagem e seus respectivos problemas?&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;O número de alunos em toda a história de Computação @ UFCG até a escrita desse material não passava de 2000.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Árvores Binárias de Pesquisa</title>
         <link>https://joaoarthurbm.github.io/eda/posts/bst/</link>
         <pubDate>Wed, 23 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/bst/</guid>
         <description>

&lt;hr /&gt;

&lt;h1 id=&#34;definições-e-propriedades&#34;&gt;Definições e Propriedades&lt;/h1&gt;

&lt;p&gt;Árvores binárias são estruturas de dados fundamentais no contexto de Ciência da Computação. Em particular, Árvores Binárias de Pesquisa são aplicadas na solução de diversos problemas que demandam eficiência em operações básicas, como busca. Informalmente, uma Árvore Binária de Pesquisa (BST)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Outras-denomina&#34;&gt;&lt;a href=&#34;#fn:Outras-denomina&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; é uma estrutura de dados de árvore binária baseada em nós, onde a subárvore à esquerda de cada nó possui valores numéricos inferiores ao nó e a subárvore à direita de cada nó possui valores numéricos superiores ao nó. Formalmente, uma
BST é definida recursivamente da seguinte forma:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$A$ é uma árvore nula;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$A$ é uma tripla $(Esq, raiz, Dir)$, onde &lt;strong&gt;&lt;em&gt;Esq&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;Dir&lt;/em&gt;&lt;/strong&gt; são árvores binárias de pesquisa e &lt;strong&gt;&lt;em&gt;Esq&lt;/em&gt;&lt;/strong&gt; contém apenas valores menores do que o armazenado na raiz, enquanto &lt;strong&gt;&lt;em&gt;Dir&lt;/em&gt;&lt;/strong&gt; contém apenas valores maiores do que o armazenado na raiz.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A Figura abaixo&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:As-figuras-desse&#34;&gt;&lt;a href=&#34;#fn:As-figuras-desse&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; ilustra uma árvore com raiz 63.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst1.png&#34; alt=&#34;bst1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;o-nó&#34;&gt;O nó&lt;/h2&gt;

&lt;p&gt;Árvores são baseadas em nós. Do ponto de vista de código, temos:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; {
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
    
    Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
    }
    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em primeiro lugar, um nó pode armazenar qualquer objeto como valor. Neste material estamos utilizando um valor inteiro para simplificar.&lt;/p&gt;

&lt;p&gt;Depois, as referências &lt;strong&gt;&lt;em&gt;left&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt; são muito parecidas com as referências de um &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; em &lt;a href=&#34;https://joaoarthurbm.github.io/eda/posts/linkedlist/&#34;&gt;Listas Duplamente Encadeadas&lt;/a&gt;, lembra? A única diferença aqui é que garantimos por construção que o nó para o qual a referência &lt;strong&gt;&lt;em&gt;left&lt;/em&gt;&lt;/strong&gt; aponta é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou  armazena um &lt;strong&gt;valor menor&lt;/strong&gt; do que &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt;, enquanto o nó para o qual a referência &lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt; aponta é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou armazena um &lt;strong&gt;valor maior&lt;/strong&gt; do que &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt;. Essa restrição deve ser verdadeira para todo e qualquer nó da árvore.&lt;/p&gt;

&lt;p&gt;Formalmente uma árvore é um grafo que não contém ciclos. Todavia, na prática, nós acrescentamos a referência &lt;strong&gt;&lt;em&gt;parent&lt;/em&gt;&lt;/strong&gt; que liga um nó ao seu pai. Ou seja, na prática não estamos falando de árvore, pois há um ciclo entre cada nó e seu pai. Nós vamos conviver com esse conflito porque essa referência facilita muito caminhar árvore acima, o que é preciso em alguns algoritmos.&lt;/p&gt;

&lt;h2 id=&#34;raiz&#34;&gt;Raiz&lt;/h2&gt;

&lt;p&gt;Raiz é um nó especial da árvore. Através dele conseguimos acessar qualquer nó. Assim como mantemos uma referência para a o início de uma lista encadeada para poder acessar o restante dos elementos, na BST mantemos a referência para a raiz da árvore. A raiz da árvore ilustrada pela figura acima é 63.&lt;/p&gt;

&lt;h2 id=&#34;grau-de-um-nó&#34;&gt;Grau de um nó&lt;/h2&gt;

&lt;p&gt;O grau de um nó é a quantidade de filhos que ele possui. Naturalmente, só temos três graus possíveis em uma árvore binária de pesquisa: 0, 1 e 2. Os nós com grau zero são chamados de folhas. Na figura acima, as folhas são os nós 2, 52, 60, 65 e 83. Os nós com graus 1 e 2 são chamados de nós internos.&lt;/p&gt;

&lt;h2 id=&#34;altura&#34;&gt;Altura&lt;/h2&gt;

&lt;p&gt;A altura de uma árvore binária de pesquisa é o maior caminho entre a raiz e todas as folhas. Vamos analisar novamente a nossa árvore exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst1.png&#34; alt=&#34;bst1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para determinarmos a altura, precisamos calcular o tamanho dos caminhos entre a raiz e todas as folhas. Vamos lá:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;63 -&amp;gt; 7 -&amp;gt; 2. Tamanho do caminho = 2.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 7 -&amp;gt; 59 -&amp;gt; 52. Tamanho do caminho = 3.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 7 -&amp;gt; 59 -&amp;gt; 60. Tamanho do caminho = 3.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 69 -&amp;gt; 65. Tamanho do caminho = 2.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 69 -&amp;gt; 90 -&amp;gt; 83. Tamanho do caminho = 3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como dito anteriormente, a altura da árvore é o maior caminho, ou seja, h=3.&lt;/p&gt;

&lt;p&gt;A altura de uma árvore com apenas um nó é 0, enquanto a altura de uma árvore nula é -1.&lt;/p&gt;

&lt;p&gt;Esse conceito é importante pois várias operações básicas, como inserção, busca e remoção em uma BST são, do ponto de vista assintótico, $O(h)$. Portanto, idealmente, é preciso manter $h$ com o menor valor possível para que as operações sejam eficientes. No entanto, isso nem sempre é possível. Uma combinação de inserções e remoções pode levar a árvore a um estado em que a altura da sub-árvore à direita pode ser muito maior que a altura da sub-árvore à esquerda (e vice-versa). Quando a árvore atinge esse estado, dizemos que ela está desbalanceada. De maneira geral, uma árvore balanceada é aquela que a altura é $O(\log n)$.&lt;/p&gt;

&lt;h2 id=&#34;árvore-completa&#34;&gt;Árvore Completa&lt;/h2&gt;

&lt;p&gt;Uma árvore completa é aquela que todos os nós, exceto folhas, possuem grau 2 e as folhas estão no mesmo nível. Veja o exemplo abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst-completa.png&#34; alt=&#34;bst-completa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Importante aqui notar que a árvore contém 15 nós e altura 3. De maneira geral, não é difícil perceber que o número máximo de nós em uma árvore binária de altura $h$ é $2^{h+1} - 1$.&lt;/p&gt;

&lt;p&gt;Também é importante destacar que uma árvore completa possui a menor altura possível para a sua quantidade de nós. Essa altura é $h = \log (n+1)-1$, ou seja, $O(\log n)$. Isso faz com que os principais algoritmos sejamO(log n), pois são dependentes da altura.&lt;/p&gt;

&lt;h2 id=&#34;sucessor&#34;&gt;Sucessor&lt;/h2&gt;

&lt;p&gt;O sucessor de um elemento na árvore é o menor valor maior do que ele. Complicado? Imagine se pudéssemos imprimir a sequência dos valores presentes na árvore de forma ordenada. O sucessor de um elemento, seria o elemento imediatamente à frente. Por exemplo, o sucessor de 41 na árvore acima é 45. O sucessor de 15 é 20. O sucessor de 72 é 91. Naturalmente, o maior valor armazenado na árvore (99) não tem sucessor.&lt;/p&gt;

&lt;h2 id=&#34;predecessor&#34;&gt;Predecessor&lt;/h2&gt;

&lt;p&gt;O predecessor de um elemento na árvore é o maior valor menor do que ele. Complicado? Imagine se pudéssemos imprimir a sequência dos valores presentes na árvore de forma ordenada. O predecessor de um elemento, seria o elemento imediatamente antes na sequência. Por exemplo, o predecessor de 41 na árvore acima é 32. O predecessor de 15 é 11. O predecessor de 72 é 65. Naturalmente, o menor valor armazenado na árvore (1) não tem predecessor.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;implementação&#34;&gt;Implementação&lt;/h1&gt;

&lt;p&gt;Assim como &lt;a href=&#34;http://joaoarthurbm.github.io/eda/posts/linkedlist&#34;&gt;LinkedList&lt;/a&gt;, a classe &lt;strong&gt;&lt;em&gt;BST&lt;/em&gt;&lt;/strong&gt; é nada mais do que um controlador das referências para os nós, mantendo apenas a referência para a raiz da árvore. Vamos ver como isso é feito em Java:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; BST {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; root;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; isEmpty() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
    ...
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; {
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
    
    Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
    }
    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;operações-básicas-e-outros-algoritmos&#34;&gt;Operações Básicas e outros algoritmos&lt;/h2&gt;

&lt;h3 id=&#34;inserção&#34;&gt;Inserção&lt;/h3&gt;

&lt;p&gt;Primeiro, vamos ilustrar como se adiciona elementos em uma árvore binária de pesquisa. Somente depois nos preocupamos com o código, ok?&lt;/p&gt;

&lt;p&gt;Suponha que os seguintes elementos devem ser adicionados em uma árvore binária de pesquisa nessa ordem: 41, 65, 20, 19 e 50. Inicialmente temos a árvore vazia. Nesse caso, 41 assume o papel da raiz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;insercao-bst.png&#34; alt=&#34;insercao-bst&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Depois disso, 65 é adicionado à direita de 41, pois é um valor maior. 20 é adicionado à esquerda de 41, por ser menor do que esse valor. Depois 19 é comparado com 41, por ser menor, a adição deve ser feita à esquerda. Contudo, já há o elemento 20 à esquerda. Então compara-se 19 com 20. Como 19 é menor e não há nenhum nó à esquerda de 20, 19 assume essa posição. A última adição é a do valor 50. Inicialmente é comparado com a raiz e a inserção deve ser feita à direita. Então compara-se 50 com 65. Por ser menor e não haver nó à esquerda de 65, 50 assume essa posição.&lt;/p&gt;

&lt;p&gt;Note que todo novo nó é adicionado como folha na árvore.&lt;/p&gt;

&lt;p&gt;Podemos implementar a adição de maneira iterativa e recursiva. Vamos analisar primeiro a adição iterativa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; add(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty())
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
                
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { 
                    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
                    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
                    newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
                }
                    
                aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { 
                    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
                    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
                    newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
                }
                    
                aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
            }
        }
    }
        
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A primeira verificação é feita para saber se a árvore é vazia. Se sim, basta fazermos a raiz apontar para o novo nó &lt;code&gt;this.root = new Node(element)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Caso não seja a primeira adição precisamos seguir o passo a passo ilustrado anteriormente. Ou seja, caminhar árvore abaixo fazendo a comparação do elemento adicionado com os nós no caminho. Se o elemento for menor, caminhamos para a esquerda (&lt;code&gt;aux = aux.left&lt;/code&gt;). Se for maior, caminhamos para a direita (&lt;code&gt;aux = aux.right&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;A adição é feita quando &lt;code&gt;aux.left == null&lt;/code&gt;, se o elemento for menor ou &lt;code&gt;aux.right == null&lt;/code&gt;, se o elemento for maior. Note que o trecho liga não somente o pai ao novo nó, mas também liga o novo nó ao pai (&lt;code&gt;newNode.parent = aux&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Agora vamos nos debruçar sobre a implementação recursiva.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; recursiveAdd(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty())
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        recursiveAdd(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;, element);
    }
        
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; recursiveAdd(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
            node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        recursiveAdd(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;, element);
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
            node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        recursiveAdd(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;, element);
    }
        
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Usamos dois métodos para implementar a recursão. O primeiro, público, tem a assinatura padrão que recebe o valor a ser adicionado. Esse método verifica se a árvore é nula e, se for, faz com que a referência &lt;strong&gt;&lt;em&gt;root&lt;/em&gt;&lt;/strong&gt; aponte para o novo nó (&lt;code&gt;this.root = new Node(element)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;O outro método também recebe como parâmetro o elemento adicionado, além de receber o nó atualmente sendo analisado. Inicialmente o primeiro nó passado é a raiz.&lt;/p&gt;

&lt;p&gt;As verificações e condições de parada são as mesmas da versão iterativa:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;se o elemento é menor e a esquerda é nula, adiciona-se o elemento à esquerda do nó atual. Se o elemento é menor e a esquerda não é nula, chama-se recursivamente o método add passando como parâmetro o nó à esquerda;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;se o elemento é maior e a direita é nula, adiciona-se o elemento à direita do nó atual. Se o elemento é maior e a direita não é nula, chama-se recursivamente o método add passando como parâmetro o nó à direita.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Em ambas as estratégias o novo elemento é adicionado como folha. Portanto, no pior caso, a adição tem tempo de execução dado por $O(h)$, pois $h$ é o maior caminho entre a raiz e todas as folhas.&lt;/p&gt;

&lt;h3 id=&#34;busca&#34;&gt;Busca&lt;/h3&gt;

&lt;p&gt;A busca em uma árvore binária de pesquisa também usa as propriedades de ordenação dos nós para decidir que caminho percorrer. Compara-se o elemento com a raiz. Se for maior, a busca deve seguir pela sub-árvore à direita (&lt;code&gt;aux = aux.right&lt;/code&gt;). Caso contrário, deve seguir pela sub-árvore à esquerda (&lt;code&gt;aux = aux.left&lt;/code&gt;). Esse mesmo processo é feito com a raiz dessas sub-árvores. O algoritmo pára se o elemento for encontrado (&lt;code&gt;aux.value == element&lt;/code&gt;) ou se alcançar uma folha e não encontrar o elemento (&lt;code&gt;aux == null&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Veja abaixo a versão iterativa da busca binária.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; search(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {   
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; element) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;

}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A versão recursiva da busca binária também utiliza dois métodos. O método público seguindo a assinatura padrão e um privado auxiliar para controlar a recursão.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; recursiveSearch(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; recursiveSearch(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;, element);
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; recursiveSearch(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; node;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; recursiveSearch(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;, element);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; recursiveSearch(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;, element);
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A ideia é a mesma. Compara-se o elemento com o nó atual. Se for menor, há uma chamada recursiva para a sub-árvore à esquerda (&lt;strong&gt;&lt;em&gt;recursiveSearch(node.left, element)&lt;/em&gt;&lt;/strong&gt;). Se for menor, há uma chamada recursiva para a direita (&lt;strong&gt;&lt;em&gt;recursiveSearch(node.right, element)&lt;/em&gt;&lt;/strong&gt;). O algoritmo pára o nó sob análise for nulo.&lt;/p&gt;

&lt;p&gt;A busca binária tem seu tempo de execução dependente da altura da árvore, pois no pior caso o algoritmo percorre um ramo da árvore até o final e esse ramo tem altura $h$. Assim, a busca binária é $O(h)$.&lt;/p&gt;

&lt;h3 id=&#34;mínimo-e-máximo&#34;&gt;Mínimo e Máximo&lt;/h3&gt;

&lt;p&gt;Mínimo é o menor valor presente na árvore, enquanto máximo é o maior. Para encontrar o mínimo, basta caminharmos na árvore para a esquerda até que não haja mais nós. O último nó visitado é o mínimo. De maneira análoga, o máximo é o último elemento mais à direita na árvore. Abaixo estão as implementações desses métodos. O mínimo é implementado de maneira recursiva, enquanto o máximo de maneira iterativa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; min() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; min(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; node;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; max() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;      

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; node;

}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;sucessor-1&#34;&gt;Sucessor&lt;/h3&gt;

&lt;p&gt;Se um nó possui sub-árvore à direita, o seu sucessor é o mínimo dessa sub-árvore. Vamos a um exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst-completa.png&#34; alt=&#34;bst-completa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Qual é o sucessor de 20? Se há sub-árvore à direita, basta retornamos o mínimo dessa sub-árvore. Ou seja, 27.&lt;/p&gt;

&lt;p&gt;E se não houver sub-árvore à direita? Por exemplo, qual é o sucessor de 55? Como não há sub-árvore à direita, precisamos subir na árvore até encontrar um elemento maior do que 55. Primeiro comparamos com 50. Como 50 é menor, subimos para 65. Encontramos o sucessor de 55, pois é o primeiro elemento árvore acima maior do que ele.&lt;/p&gt;

&lt;p&gt;Você não precisa decorar isso, certo? Faz todo sentido procurar pelo mínimo da sub-árvore à direita, pois é lá que estão os valores maiores que o nó. O mínimo deles é o sucessor. E se não houver sub-árvore à direita, é natural que o sucessor esteja árvore acima, pois à esquerda todos os valores são menores. Então o algoritmo verifica árvore acima o primeiro elemento maior que o nó sob análise.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; sucessor(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
            aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O método recebe o nó para o qual deseja se encontrar o sucessor. Se esse nó for nulo, o método retorna nulo. Caso contrário, verifica-se se há sub-árvore à direita (&lt;code&gt;node.right != null&lt;/code&gt;). Se houver, retorna-se o mínimo dessa sub-árvore.&lt;/p&gt;

&lt;p&gt;Caso não haja sub-árvore à direita, caminhamos árvore acima (&lt;code&gt;aux = aux.parent&lt;/code&gt;) até encontrarmos um elemento maior ou subirmos toda a árvore e não encontrarmos (&lt;code&gt;aux == null&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;predecessor-1&#34;&gt;Predecessor&lt;/h3&gt;

&lt;p&gt;A identificação do predecessor é muito semelhante ao sucessor.
Se um nó possui sub-árvore à esquerda, o seu predecessor é o máximo dessa sub-árvore. Vamos a um exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst-completa.png&#34; alt=&#34;bst-completa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Qual é o predecessor de 20? Se há sub-árvore à esquerda, basta retornamos o máximo dessa sub-árvore. Ou seja, 15.&lt;/p&gt;

&lt;p&gt;E se não houver sub-árvore à esquerda? Por exemplo, qual é o predecessor de 27? Como não há sub-árvore à esquerda, precisamos subir na árvore até encontrar um elemento menor do que 27. Primeiro comparamos com 29. Como 29 é maior, subimos para 20. Encontramos o predecessor de 27, pois é o primeiro elemento árvore acima menor do que ele.&lt;/p&gt;

&lt;p&gt;Você não precisa decorar isso, certo? Faz todo sentido procurar pelo máximo da sub-árvore à esquerda, pois é lá que estão os valores menores que o nó. O máximo deles é o predecessor. E se não houver sub-árvore à esquerda, é natural que o predecessor esteja árvore acima, pois à direita todos os valores são maiores. Então o algoritmo verifica árvore acima o primeiro elemento menor que o nó sob análise.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; predecessor(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
            aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;altura-1&#34;&gt;Altura&lt;/h3&gt;

&lt;p&gt;Como dito anteriormente, a altura é o maior caminho entre a raiz e todas as folhas.
A implementação é bem simples. Basta somar 1 cada vez que um novo nó é visitado e calcular
de maneira recursiva o máximo entre a altura da sub-árvore à esquerda e da sub-árvore à direita. Lembrando que a altura de uma árvore cuja raiz é nula é -1.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; height() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; height(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; height(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(height(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;), height(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;));
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;remoção&#34;&gt;Remoção&lt;/h3&gt;

&lt;p&gt;A remoção em uma árvore binária de pesquisa possui três casos a serem analisados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Caso 1: O nó a ser removido é uma folha.&lt;/strong&gt; Nesse caso, basta fazermos com que o pai do nó, se existir, passe a apontar a sua direita ou a esquerda para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Precisamos também verificar se o nó removido é raiz. Se for, simplesmente fazemos a raiz apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;isLeaf&lt;/span&gt;()) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Caso 2: O nó a ser removido possui apenas um filho.&lt;/strong&gt; Se o nó possuir apenas um filho, precisamos ligar esse filho ao pai do nó a ser removido. Naturalmente, precisamos diferenciar se o único filho é à esquerda ou à direita. Além disso, precisamos verificar se o nó removido é a raiz da árvore.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasOnlyLeftChild&lt;/span&gt;()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;)  {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
        }
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasOnlyRightChild&lt;/span&gt;()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
        }
            
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Caso 3: O nó a ser removido possui dois filhos.&lt;/strong&gt; Nesse caso, trocamos o nó com o seu sucessor e chamamos recursivamente o método remove passando o nó sucessor.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;sucessor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sucessor(toRemove);
        toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sucessor.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
        remove(sucessor);
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;percorrendo-árvores-binárias&#34;&gt;Percorrendo Árvores Binárias&lt;/h2&gt;

&lt;p&gt;De maneira geral, há duas estratégias para percorrer um grafo: em profundidade (&lt;em&gt;depth-first search&lt;/em&gt;) e em largura (&lt;em&gt;breadth-first search&lt;/em&gt;). Essas estratégias são utilizadas em diversos algoritmos fundamentais em Ciência da Computação. Por exemplo, o algoritmo de Dijkstra, que calcula o menor caminho entre qualquer par de vértices em um grafo, segue a estratégia em profundidade. A busca em largura é também bastante utilizada para análise de mapas. Por exemplo, se um grafo representa o mapa onde os vértices são as cidades e as arestas o caminho entre elas, podemos utilizar busca em largura para determinar o número de cidades no caminho entre duas delas.&lt;/p&gt;

&lt;p&gt;Ambas as estratégias têm como objetivo percorrer o grafo. O que as difere é a decisão de qual nó visitar primeiro quando houver mais de uma possibilidade. Trocando em miúdos, a diferença é a ordem de visitação dos nós.&lt;/p&gt;

&lt;h3 id=&#34;em-profundidade&#34;&gt;Em Profundidade&lt;/h3&gt;

&lt;p&gt;A ideia é escolher um nó de partida e explorar todo o ramo da árvore antes de voltar e visitar os outros ramos. Vamos adotar essa estratégia para percorrer a árvore abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O mantra é: para cada nó visitado explore o máximo à esquerda deste nó e depois o máximo à direita.&lt;/p&gt;

&lt;p&gt;Inicialmente escolhemos como ponto de partida a raiz. No nosso caso, visitar significa que vamos imprimir o nó, ok? Então o primeiro nó impresso é 52.&lt;/p&gt;

&lt;p&gt;Depois disso, vamos explorar o ramo o máximo à esquerda. Então decidimos ir para 22. Novamente, explorando o máximo à esquerda, o próximo nó a ser visitado é o 8. Até aqui temos a seguinte impressão: 52 -&amp;gt; 22 -&amp;gt; 8.&lt;/p&gt;

&lt;p&gt;Neste ponto já exploramos o máximo da esquerda de 8, agora vamos para a direita. Então imprimimos o valor 11. Até aqui temos: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11.&lt;/p&gt;

&lt;p&gt;Como não há mais direita nem esquerda a ser explorada de 8, subimos para 22. A esquerda de 22 já foi toda explorada, então vamos para a direita. Visitamos 43. Lembre-se, &lt;strong&gt;para cada nó&lt;/strong&gt; eu tenho que visitar toda a esquerda e depois a direita. Então vamos para a esquerda de 43, que é 26. O resultado parcial até aqui é: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11 -&amp;gt; 43 -&amp;gt; 26.&lt;/p&gt;

&lt;p&gt;Voltamos para 52 e exploramos a direita, isto é 85. Imprimimos 85 e vamos o máximo para a esquerda.  O resultado parcial é então: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11 -&amp;gt; 43 -&amp;gt; 26 -&amp;gt; 85 -&amp;gt; 81 -&amp;gt; 69.&lt;/p&gt;

&lt;p&gt;Exploramos toda a esquerda de 69. Agora vamos para a direita. 74. Depois subimos e vamos para a direita de 81, que não existe e, por isso, não imprimimos nada. Por fim subimos até 85 e visitamos a sua direita (96).&lt;/p&gt;

&lt;p&gt;O resultado final desse percurso em profundidade é: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11 -&amp;gt; 43 -&amp;gt; 26 -&amp;gt; 85 -&amp;gt; 81 -&amp;gt; 69 -&amp;gt; 74 -&amp;gt; 96.&lt;/p&gt;

&lt;p&gt;Essa é uma das estratégias de percorrer uma árvore em profundidade. Lembra que escolhemos explorar o nó, sua esquerda e depois a sua direita? Essa escolha tem um nome particular &lt;strong&gt;percurso em pré-ordem&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; preOrder() {
    preOrder(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; preOrder(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;);
        preOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
        preOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Há outras duas escolhas clássicas: em-ordem e pós-ordem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Em-ordem: esquerda, nó, direita.&lt;/strong&gt; Neste tipo de percurso em profundidade, primeiro visitamos toda a esquerda de um nó, depois visitamos o nó e só depois a sua direita. Retomando nosso exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para a árvore acima, temos como resultado o seguinte percurso: 8 -&amp;gt; 11 -&amp;gt; 22 -&amp;gt; 26 -&amp;gt; 43 -&amp;gt; 52 -&amp;gt; 69 -&amp;gt; 74 -&amp;gt; 81 -&amp;gt; 85 -&amp;gt; 96. Note que o resultado do caminho em-ordem em uma árvore binária de pesquisa é sempre uma sequência ordenada.&lt;/p&gt;

&lt;p&gt;Como isso foi feito? Aplicando o mantra &amp;ldquo;esquerda, nó, direita&amp;rdquo; para cada nó visitado. Inicialmente escolhemos a raíz. Note que só vamos imprimir a raiz depois de visitar todos os nós à sua esquerda. Isso é verdade para cada nó visitado. Por isso, caminhamos o máximo à esquerda e o primeiro elemento a ser impresso é 8. Depois disso 11, 22, 26, 43&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; inOrder() {
    inOrder(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; inOrder(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        inOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;);
        inOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Pós-ordem: esquerda, direita, nó.&lt;/strong&gt; Neste tipo de percurso em profundidade, primeiro visitamos toda a esquerda de um nó, depois visitamos toda a direita e só depois visitamos o nó. Retomando nosso exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para a árvore acima, temos como resultado o seguinte percurso: 11 -&amp;gt; 8 -&amp;gt; 26 -&amp;gt; 43 -&amp;gt; 22 -&amp;gt; 74 -&amp;gt; 69 -&amp;gt; 81 -&amp;gt; 96 -&amp;gt; 85 -&amp;gt; 52. Note que o resultado do caminho em-ordem em uma árvore binária de pesquisa sempre tem a raíz como último elemento.&lt;/p&gt;

&lt;p&gt;Como isso foi feito? Aplicando o mantra &amp;ldquo;esquerda, direita, nó&amp;rdquo; para cada nó visitado. Inicialmente escolhemos a raíz. Note que só vamos imprimir a raiz depois de visitar todos os nós à sua esquerda e todos os nós à sua direita. Isso é verdade para cada nó visitado. Por isso, caminhamos o máximo à esquerda e depois o máximo à direita. O primeiro elemento a ser impresso é 11. Depois disso 8, 26, 43, 22&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; posOrder() {
    posOrder(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; posOrder(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        posOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
        posOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;);
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;em-largura&#34;&gt;Em Largura&lt;/h3&gt;

&lt;p&gt;O percurso em largura explora inicialmente todos os filhos de um nó primeiro antes de  descer na árvore. Profundidade desce e depois volta. Largura vai descendo &amp;ldquo;varrendo&amp;rdquo; todos os nós no caminho.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para essa árvore, o resultado do percurso é 52 -&amp;gt; 22 -&amp;gt; 85 -&amp;gt; 8 -&amp;gt; 43 -&amp;gt; 81 -&amp;gt; 96 -&amp;gt; 11 -&amp;gt; 26 -&amp;gt; 69 -&amp;gt; 74.&lt;/p&gt;

&lt;p&gt;Como isso é feito? Para cada nó visitado, exploramos todos os seus filhos antes de seguir adiante. Começamos em 52 e, portanto visitamos 22 e 85. Depois vamos para 22, visitando 8 e 43. Depois 85, visitando 81 e 96 e assim por diante. Veja que esse percurso visita todo o primeiro nível da árvore, depois todos o segundo nível, depois todo o terceiro e assim por diante.&lt;/p&gt;

&lt;p&gt;E como isso é feito? Usamos uma fila para nos auxiliar. O algoritmo é o seguinte.&lt;/p&gt;

&lt;p&gt;Inicia-se a fila com a raiz: &lt;pre&gt;Q = {52}&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Enquanto a fila não estiver vazia, retira-se o primeiro elemento da fila e coloca o seu filho à esquerda e o seu filho à direita na fila. Então retiramos (e imprimimos) 52 da fila e colocamos 22 e 85.&lt;/p&gt;

&lt;pre&gt;Impresso: 52
Q = {&lt;strike&gt;52&lt;/strike&gt;, 22, 85}&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 22 e colocamos 8 e 43.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22
Q = {&lt;strike&gt;52, 22&lt;/strike&gt;, 85, 8, 43}&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 85 e colocamos 81 e 96.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85
Q = {&lt;strike&gt;52, 22, 85&lt;/strike&gt;, 8, 43, 81, 96}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 8 e colocamos apenas 11, pois 8 não possui sub-árvore à esquerda.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8
Q = {&lt;strike&gt;52, 22, 85, 8&lt;/strike&gt;, 43, 81, 96, 11}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 43 e colocamos apenas 26, pois 43 não possui sub-árvore à direita.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43
Q = {&lt;strike&gt;52, 22, 85, 8, 43&lt;/strike&gt;, 81, 96, 11, 26}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 81 e colocamos apenas a sua esquerda (69), pois a direita é nula.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43, 81
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81&lt;/strike&gt;, 96, 11, 26, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 96, mas não colocamos elemento algum porque 96 é folha.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43, 81
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96&lt;/strike&gt;, 11, 26, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 11, mas não colocamos elemento algum porque 11 é folha.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43, 81, 96, 11
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11&lt;/strike&gt;, 26, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 26, mas não colocamos elemento algum porque 26 é folha.&lt;/p&gt;

&lt;pre&gt;
Impresso: 52, 22, 85, 8, 43, 81, 96, 11, 26
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11, 26&lt;/strike&gt;, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 69 e colocamos apenas o 74, pois 69 não tem sub-árvore à esquerda.&lt;/p&gt;

&lt;pre&gt;
Impresso: 52, 22, 85, 8, 43, 81, 96, 11, 26, 69
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11, 26, 69&lt;/strike&gt;, 74}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 74 e não colocamos elemento algum porque 74 é folha.&lt;/p&gt;

&lt;pre&gt;
Impresso: 52, 22, 85, 8, 43, 81, 96, 11, 26, 69, 74
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11, 26, 69, 74&lt;/strike&gt;}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Está! Finalmente :). Veja que a sequência impressa representa o caminho por níveis na árvore da esquerda para a direita.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;Percurso em largura: 52, 22, 85, 8, 43, 81, 96, 11, 26, 69, 74.&lt;/p&gt;

&lt;p&gt;Implementação em Java.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; printBFS() {
    Deque&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Node&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; LinkedList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Node&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;isEmpty()) {
        queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;()) {
            Node &lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;removeFirst&lt;/span&gt;();
                
            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(current);
                
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) 
                queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) 
                queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);   
        }
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Outras-denomina&#34;&gt;Outras denominações utilizadas são: Árvore de Pesquisa Binária, Árvore Binária de Busca (ABB) e Binary Search Tree (BST). Neste material vou usar a sigla BST devido à sua popularidade. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Outras-denomina&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:As-figuras-desse&#34;&gt; As figuras desse material foram feitas no visualgo.net  &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:As-figuras-desse&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
       </item>
       
     </channel>
   </rss>
